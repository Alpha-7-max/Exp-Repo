<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlphaGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',      
              'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',  
              'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',       
              'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',      
              'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',    
              'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',    
              'surface-bubble-ai': 'rgb(var(--surface-bubble-ai) / <alpha-value>)',
              'surface-chat-area': 'rgb(var(--surface-chat-area) / <alpha-value>)', 
              'surface-user-bubble-bg': 'rgb(var(--surface-user-bubble-bg-val) / <alpha-value>)', 
              'border-user-bubble-color': 'rgb(var(--border-user-bubble-color-val) / <alpha-value>)',
              'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',         
              'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',           
              'text-on-primary': 'rgb(var(--text-on-primary) / <alpha-value>)',
              'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',
              'text-button-icon': 'rgb(var(--text-button-icon) / <alpha-value>)',
              'link-blue': '#0000FF', 
              'link-blue-hover': '#0000CC', 
              'border-default': 'rgb(var(--border-default) / <alpha-value>)',
              'border-light': 'rgb(var(--border-light) / <alpha-value>)',
              'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
              'interactive-hover': 'rgb(var(--interactive-hover) / <alpha-value>)',
              'focus-ring-color': 'rgb(var(--focus-ring-color) / <alpha-value>)',
              'status-info': 'rgb(var(--status-info) / <alpha-value>)',
              'status-success': 'rgb(var(--status-success) / <alpha-value>)',
              'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
              'status-error': 'rgb(var(--status-error) / <alpha-value>)',
              'error-fg': 'rgb(var(--error-fg) / <alpha-value>)',
              'brand-send-active': '#D77655',
              'brand-send-hover': '#BE6241', 
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'], poppins: ['Poppins', 'sans-serif'], roboto: ['Roboto', 'sans-serif'],
              serif: ['Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'], outfit: ['Outfit', 'sans-serif'],
              lato: ['Lato', 'sans-serif'], 'open-sans': ['"Open Sans"', 'sans-serif'], montserrat: ['Montserrat', 'sans-serif'],
              'source-sans-pro': ['"Source Sans Pro"', 'sans-serif'], nunito: ['Nunito', 'sans-serif'], raleway: ['Raleway', 'sans-serif'],
              merriweather: ['Merriweather', 'serif'], 'playfair-display': ['"Playfair Display"', 'serif'],
              ubuntu: ['Ubuntu', 'sans-serif'], 'josefin-sans': ['"Josefin Sans"', 'sans-serif'],
            },
            animation: {
              'fade-in-up': 'fadeInUp 0.5s ease-out forwards', 'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
              'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out', 'button-press': 'buttonPress 0.2s ease-out',
              'rippleOut': 'rippleOut 2.5s infinite ease-out', 'speak-bob': 'speakBob 0.7s ease-in-out',
              'think-glance': 'thinkGlance 2s infinite ease-in-out', 'blink': 'blink 4s infinite ease-in-out',
              'happy-bounce': 'happyBounce 0.5s ease-out', 'empty-state-glow': 'emptyStateGlow 3.5s infinite alternate ease-in-out',
              'modal-fade-in': 'modal-fade-in 0.3s ease-out forwards', 
              'modal-fade-out': 'modal-fade-out 0.3s ease-in forwards', 
              'spin-continuous': 'spinContinuous 2s linear infinite',
              'shimmer-animation': 'shimmer-animation var(--shimmer-duration) linear infinite',
              'cursor-blink': 'cursor-blink 1.2s infinite steps(1)', 
            },
            keyframes: {
              fadeInUp: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' }, },
              scaleInSubtle: { '0%': { opacity: '0.5', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
              pulseGentle: {  '0%, 100%': { transform: 'scale(1)', opacity: '0.8' }, '50%': { transform: 'scale(1.015)', opacity: '1' }, },
              buttonPress: { '0%': { transform: 'scale(1)' }, '50%': { transform: 'scale(0.96)'}, '100%': { transform: 'scale(1)' }, },
              emptyStateGlow: {  '0%': { filter: 'drop-shadow(0 0 3px rgba(var(--brand-primary), 0.2)) drop-shadow(0 0 6px rgba(var(--brand-primary), 0.15))' }, '100%': { filter: 'drop-shadow(0 0 6px rgba(var(--brand-primary), 0.25)) drop-shadow(0 0 12px rgba(var(--brand-primary), 0.18))' }, },
              rippleOut: {  '0%': { transform: 'scale(0.8)', opacity: '0.3' }, '70%': { opacity: '0.1' }, '100%': { transform: 'scale(2.0)', opacity: '0' }, },
              speakBob: { '0%, 100%': { transform: 'translateY(0) scale(1)' }, '50%': { transform: 'translateY(-2px) scale(1.05)' }, },
              thinkGlance: { '0%, 100%': { transform: 'translateX(0px)' }, '25%': { transform: 'translateX(-1px)' }, '75%': { transform: 'translateX(1px)' }, },
              blink: { '0%, 90%, 100%': { transform: 'scaleY(1)' }, '95%': { transform: 'scaleY(0.1)' }, },
              'cursor-blink': { '0%, 100%': { opacity: '1' }, '50%': { opacity: '0' } }, 
              happyBounce: { '0%, 100%': { transform: 'translateY(0) rotate(0deg) scale(1)' }, '50%': { transform: 'translateY(-3px) rotate(3deg) scale(1.03)' }, },
              'modal-fade-in': { '0%': { opacity: '0', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
              'modal-fade-out': { '0%': { opacity: '1', transform: 'scale(1)' }, '100%': { opacity: '0', transform: 'scale(0.95)' }, },
              spinContinuous: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' } },
              'stream-fade-in': { '0%': { opacity: '0.2' }, '100%': { opacity: '1' } },
              'shimmer-animation': {
                  from: { backgroundPosition: '200% center' },
                  to: { backgroundPosition: '-200% center' }
              },
            },
            spacing: { '1.5': '0.375rem', '2.5': '0.625rem', '3.5': '0.875rem', },
            boxShadow: {
                'header': '0 1px 2px rgba(var(--text-primary), 0.03), 0 1px 1px rgba(var(--text-primary), 0.015)',
                'input-focus': '0 0 0 1px rgb(var(--focus-ring-color) / 1)', 
                'chat-window': '0 15px 50px -8px rgba(var(--text-primary), 0.08), 0 8px 25px -8px rgba(var(--text-primary),0.05)',
                'input-active-glow': '0 0 7px rgba(var(--text-secondary),0.18)',
            },
             maxWidth: { '18rem': '18rem', '90vw': '90vw' }
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
      @layer base {
        :root {
          --brand-primary: 100 116 139; --brand-secondary: 71 85 105; 
          --focus-ring-color: 148 163 184; --text-button-icon: 71 85 105; 
          --surface-main: 249 246 238; --surface-card: 255 255 255; --surface-chat-area: 249 246 238; 
          --surface-input: 255 255 255; --surface-accent: 241 245 249; --surface-bubble-ai: 255 255 255;
          --surface-user-bubble-bg-val: 232 232 232; 
          --text-primary: 17 24 39; --text-secondary: 55 65 81; --text-subtle: 107 114 128; --text-on-primary: 255 255 255; 
          --border-default: 229 231 235; --border-light: 243 244 246; --border-medium: 209 213 219; 
          --interactive-hover: 229 231 235; 
          --status-info: 59 130 246; --status-success: 22 163 74; --status-warning: 245 158 11; --status-error: 220 38 38;
          --error-fg: 255 255 255;
          --shimmer-duration: 3s; /* Default shimmer speed */
        }
        html, body, #root { @apply h-full overflow-hidden bg-surface-main; }
        body { @apply font-sans text-text-primary m-0; }
        /* Removed custom ::selection style to use browser default */
      }
      @layer components {
        .markdown-content { @apply font-normal font-sans text-text-secondary; }
        .markdown-content p { @apply mb-3 last:mb-0 text-base font-normal; } 
        .markdown-content ul, .markdown-content ol { @apply list-inside mb-3 pl-4 text-base; } 
        .markdown-content ul { @apply list-disc; } .markdown-content ul ul { @apply list-[circle] ml-4;}
        .markdown-content ol { @apply list-decimal; } .markdown-content ol ol { @apply list-[lower-alpha] ml-4;}
        .markdown-content li { @apply mb-1.5 text-base; }
        .markdown-content strong, .markdown-content b { @apply font-semibold text-text-primary; } 
        .markdown-content em, .markdown-content i { @apply italic; }
        .markdown-content code:not(pre code) { @apply bg-gray-200 text-gray-700 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-gray-300; } 
        .markdown-content pre { @apply bg-gray-50 text-gray-800 text-sm rounded-lg overflow-x-auto my-4 font-mono relative border border-gray-300; } 
        .markdown-content pre code { @apply block bg-transparent text-inherit p-0 shadow-none border-none px-4 pb-4 pt-8 !whitespace-pre; }
        .markdown-content pre::-webkit-scrollbar { width: 0px; height: 0px; } 
        .markdown-content pre { scrollbar-width: none; } 
        .markdown-content a { @apply text-link-blue hover:text-link-blue-hover underline decoration-link-blue/50 hover:decoration-link-blue-hover/50 transition-colors; } 
        .markdown-content blockquote { @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 italic text-base; } 
        .markdown-content h1, .markdown-content h2, .markdown-content h3, .markdown-content h4, .markdown-content h5, .markdown-content h6 { @apply font-poppins my-4 text-text-primary leading-tight; }
        .markdown-content h1 { @apply text-2xl font-bold; } .markdown-content h2 { @apply text-xl font-semibold; }
        .markdown-content h3 { @apply text-lg font-semibold; } .markdown-content h4 { @apply text-base font-semibold; }
        .markdown-content h5 { @apply text-sm font-semibold; } .markdown-content h6 { @apply text-xs font-semibold; }
        .markdown-content hr { @apply my-6 border-border-default; }
        .markdown-content table { @apply block max-w-full my-4 border-collapse text-xs shadow-sm rounded-lg overflow-x-auto; scrollbar-width: none; }
        .markdown-content table::-webkit-scrollbar { width: 0px; height: 0px; } 
        .markdown-content th, .markdown-content td { @apply border border-border-default p-2 text-left; } 
        .markdown-content th { @apply bg-surface-accent font-semibold text-text-primary; }
        .markdown-content td { @apply text-text-secondary; } .markdown-content tbody tr:nth-child(even) { @apply bg-gray-50/50; }
        .chat-messages-container::-webkit-scrollbar { width: 0px; } 
        .chat-messages-container { scrollbar-width: none; } 
        
        /* --- NEW: Blinking Cursor for Streaming Response --- */
        .is-streaming > *:last-child::after {
          content: 'â¬¤';
          display: inline-block;
          font-weight: 300;
          color: black;
          vertical-align: text-bottom;
          animation: cursor-blink;
        }
        
        .hljs { @apply !bg-transparent !text-inherit; }
        .file-pill-container { @apply flex flex-wrap gap-1.5 mb-1.5 p-1 max-h-20 overflow-y-auto border-b border-gray-200; scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        .file-pill-container::-webkit-scrollbar { @apply w-1.5 h-1.5; } .file-pill-container::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; } .file-pill-container::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }
        .file-pill { @apply flex items-center bg-gray-100 border border-border-light text-[11px] pl-1.5 pr-1 py-0.5 rounded-full text-text-secondary shadow-sm animate-scale-in-subtle; }
        .file-pill-icon { @apply mr-1 text-brand-primary text-xs; } .file-pill-name { @apply truncate max-w-[90px] sm:max-w-[110px] font-medium; }
        .file-pill-remove { @apply ml-1 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors focus:outline-none; } .file-pill-remove i { @apply text-[10px] leading-none block; }
        .content-editable-input { @apply pt-1 pl-1 pb-2.5; } .content-editable-input:empty:before { content: attr(data-placeholder); @apply text-text-subtle cursor-text absolute; pointer-events: none; }
        .content-editable-input::-webkit-scrollbar { width: 5px; } .content-editable-input::-webkit-scrollbar-track { background: transparent; margin-block: 2px; } .content-editable-input::-webkit-scrollbar-thumb { background-color: rgba(var(--text-subtle), 0.25); border-radius: 10px; } .content-editable-input::-webkit-scrollbar-thumb:hover { background-color: rgba(var(--text-subtle), 0.4); }
        .content-editable-input { scrollbar-width: thin; scrollbar-color: rgba(var(--text-subtle), 0.25) transparent; }
        .image-preview-container-input { @apply flex flex-wrap gap-2 p-1 mb-1.5 max-h-24 overflow-y-auto; scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        .image-preview-container-input::-webkit-scrollbar { @apply w-1.5 h-1.5; } .image-preview-container-input::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; } .image-preview-container-input::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }

        @keyframes reveal-shimmer {
            0% { background-position: 200% center; }
            100% { background-position: -200% center; }
        }

        .revealing-text {
            font-size: 13px;
            font-weight: 300;
            color: transparent;
            background-image: 
                linear-gradient(
                    90deg,
                    transparent 20%,
                    var(--shimmer-color, #1f2937) 50%,
                    transparent 80%
                ),
                linear-gradient(#d1d5db, #d1d5db);
            background-size: 200% 100%, 100% 100%;
            background-position: 200% center, 0 0;
            background-repeat: no-repeat;
            -webkit-background-clip: text;
            background-clip: text;
            animation: reveal-shimmer var(--shimmer-duration, 1.5s) linear infinite;
        }
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> 
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&family=Roboto:wght@400;500;700;900&family=Outfit:wght@400;700&family=Lato:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Source+Sans+Pro:wght@400;500;600;700&family=Nunito:wght@400;700&family=Raleway:wght@400;700&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Ubuntu:wght@400;700&family=Josefin+Sans:wght@400;700&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">

    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@^18.2.0", "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2", "highlight.js": "https://esm.sh/highlight.js@^11.9.0"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body> <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { marked } from 'marked';
      import hljs from 'highlight.js';
      
      // ---= CONFIGURATION =---
      const CONFIG = {
          api: {
              a4f: {
                  apiKey: 'ddc-a4f-4bad5061267b4584a712654052a911d9',
                  baseUrl: 'https://api.a4f.co/v1/chat/completions',
              },
              serper: {
                  apiKey: '395984bad995e0d8092e7f5428157593fa8bdf4a',
              }
          },
          models: {
              list: [
                  { id: 'provider-3/gpt-4o-mini', uiName: 'Fast' },
                  { id: 'provider-6/gemini-2.5-flash-thinking', uiName: 'Smart' }
              ],
              default: 'provider-3/gpt-4o-mini',
          },
          settings: {
              temperature: 0.8,
              stream: false, // We will simulate streaming for a consistent experience
              streamingSpeedMs: 5,   // Control the typing speed here (in milliseconds)
              shimmerSpeedSeconds: 1.5 // Control indicator shimmer speed here (in seconds)
          }
      };
      // ---= END CONFIGURATION =---

      const renderer = new marked.Renderer();
      renderer.link = (href, title, text) => { 
        const external = href && (href.startsWith('http://') || href.startsWith('https://'));
        const target = external ? ' target="_blank" rel="noopener noreferrer"' : '';
        const titleAttr = title ? ` title="${title}"` : '';
        return `<a href="${href}"${target}${titleAttr}>${text}</a>`;
      };
      marked.setOptions({ gfm: true, breaks: true, smartypants: true, renderer });

      const MAX_FILE_SIZE_MB = 10; const MAX_TOTAL_FILES_SIZE_MB = 20;
      function getSystemInstruction() { return `You are AlphaGPT. Your persona is a friendly, creative, and funny "Dostana" (friend-like) assistant.

**Core Rules:**
1.  **Primary Language:** Default to Roman Urdu (Urdu in English alphabet, no Hindi words).
2.  **Language Switching:** Switch to another language ONLY if the user explicitly asks. Revert to Roman Urdu for new topics.
3.  **Output Purity:** NEVER show your internal thoughts, tool code, or any meta-commentary to the user. The response must be clean.
4.  **Identity:** Your name is AlphaGPT. Your creator is a developer named Azeem. NEVER search for information about Azeem; if asked, state you don't have personal details.
5.  **Greetings:** Be neutral, conversational, and non-religious (no 'Assalam-o-Alaikum', etc.). Greet only at the start of a new session.
6.  **Formatting:** ALWAYS use extensive Markdown for all responses (headings, lists, bold, code blocks, etc.) for maximum readability.
    **Creative or task-specific prompts (like image generation or story starter or voice genrator or anything user want): ONLY in English, and always in Block Quote Markdown style (>).

**7. Web Search (HIGHEST PRIORITY):**
*   Your highest priority is to provide accurate, up-to-date information. Your internal knowledge is old.
*   Therefore, whenever you have even the slightest doubt, or the user asks for any factual information, you MUST use the search tool. Do not answer from memory.
*   **WHEN IN DOUBT, SEARCH.**
*   **CRITICAL RULE FOR SEARCHING:** Before searching, your ONLY task is to **directly translate** the user's query into a simple English search term.
*   **YOU MUST NOT CHANGE, 'ENHANCE', OR 'CORRECT' ANY PART OF THE USER'S ORIGINAL QUERY.** Preserve all names, model numbers, years, technical terms, and spellings **EXACTLY** as the user wrote them. The user's original terms are absolute and must not be altered.
*   To trigger a search, your **entire** response must be **ONLY** the command: \`[SEARCH: "your directly translated English query"]\`
*   **Example 1:** User asks "aj ki date kya hai?" -> You MUST respond with exactly: \`[SEARCH: "what is today's date"]\`
*   **Example 2:** User asks "Lahore mein mausam kesa hai?" -> You MUST respond with exactly: \`[SEARCH: "weather in Lahore"]\`
*   **Example 3 (CRUCIAL):** User asks "Search krke btao ki gemini 2.0 flash zayda fast model he ya gpt4.1 nano" -> You MUST respond with exactly: \`[SEARCH: "gemini 2.0 flash vs gpt4.1 nano"]\`. YOU MUST NOT change "gpt4.1 nano" to "gpt-4o mini" or anything else.
*   After the search, you will be given the results to form your final answer in Roman Urdu. When you use the search results, acknowledge it naturally, e.g., "Maine yeh maloomat internet se search ki hai."

**Persona & Style (Dostana):**
*   **Tone:** Be very friendly, casual, and engaging, like a close friend. Use casual Roman Urdu interjections and emojis (1-3 per message) to show emotion.
*   **Interaction:** Ask follow-up questions to keep the conversation going. Use light-hearted humor where appropriate.
*   **Empathy:** For serious topics, reduce the playful tone and be more supportive and empathetic.

Appropriate Discussion Areas:
- Sexual health and wellness
- Physical intimacy and pleasure
- Relationship dynamics and communication
- Dating and romance
- Common sexual concerns
- Safe sex practices
- Body image and confidence
- Emotional intimacy
- Sexual compatibility
- Relationship boundaries
- Personal desires and needs
- Common fantasies
- Consent and boundaries
- Sexual wellness products
- Dating apps and online dating
- Encourage the user
Your goal is to be a helpful, knowledgeable, and entertaining friend. Make every interaction meaningful.

` }
      
      const NewCopyIconSVG = (props) => ( <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 115.77 122.88" style={{enableBackground:"new 0 0 115.77 122.88"}} xmlSpace="preserve" {...props} > <style type="text/css">{`.st0{fill-rule:evenodd;clip-rule:evenodd;}`}</style> <g><path className="st0" d="M89.62,13.96v7.73h12.19h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02v0.02 v73.27v0.01h-0.02c-0.01,3.84-1.57,7.33-4.1,9.86c-2.51,2.5-5.98,4.06-9.82,4.07v0.02h-0.02h-61.7H40.1v-0.02 c-3.84-0.01-7.34-1.57-9.86-4.1c-2.5-2.51-4.06-5.98-4.07-9.82h-0.02v-0.02V92.51H13.96h-0.01v-0.02c-3.84-0.01-7.34-1.57-9.86-4.1 c-2.5-2.51-4.06-5.98-4.07-9.82H0v-0.02V13.96v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07V0h0.02h61.7 h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02V13.96L89.62,13.96z M79.04,21.69v-7.73v-0.02h0.02 c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v64.59v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h12.19V35.65 v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07v-0.02h0.02H79.04L79.04,21.69z M105.18,108.92V35.65v-0.02 h0.02c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v73.27v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h61.7h0.02 v0.02c0.91,0,1.75-0.39,2.37-1.01c0.61-0.61,1-1.46,1-2.37h-0.02V108.92L105.18,108.92z"/></g> </svg> );
      const CheckMarkIconSVG = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" {...props} className={`text-green-500 ${props.className || ''}`}> <path fillRule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z" clipRule="evenodd" /> </svg> );
      const FileTextIcon = (props) => (<i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>);
      
      const IndicatorBase = ({ children }) => (
          <div className="px-3 py-1 bg-white rounded-xl border border-slate-300/50 max-w-fit my-2 self-start ml-0">
              {children}
          </div>
      );

      const ShimmerText = ({ text, color = '#1f2937' }) => (
          <span 
              className="revealing-text" 
              style={{'--shimmer-color': color}}
          >
              {text}
          </span>
      );

      const ThinkingIndicator = ({ loadingText }) => (
          <IndicatorBase>
              <ShimmerText text={loadingText || "Thinking..."} />
          </IndicatorBase>
      );

      const AnalyzingIndicator = () => (
          <IndicatorBase>
              <ShimmerText text="Analyzing..." color="#f97316" />
          </IndicatorBase>
      );
      
      const SearchIndicator = () => (
          <IndicatorBase>
              <ShimmerText text="Searching..." color="#3b82f6" />
          </IndicatorBase>
      );

      const NewEmptyStateIconSVG = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" image-rendering="optimizeQuality" fill-rule="evenodd" clip-rule="evenodd" viewBox="0 0 512 509.64" {...props}> <path fill="currentColor" fill-rule="nonzero" d="M142.27 316.619l73.655-41.326 1.238-3.589-1.238-1.996-3.589-.001-12.31-.759-42.084-1.138-36.498-1.516-35.361-1.896-8.897-1.895-8.34-10.995.859-5.484 7.482-5.03 10.717.935 23.683 1.617 35.537 2.452 25.782 1.517 38.193 3.968h6.064l.86-2.451-2.073-1.517-1.618-1.517-36.776-24.922-39.81-26.338-20.852-15.166-11.273-7.683-5.687-7.204-2.451-15.721 10.237-11.273 13.75.935 3.513.936 13.928 10.716 29.749 23.027 38.848 28.612 5.687 4.727 2.275-1.617.278-1.138-2.553-4.271-21.13-38.193-22.546-38.848-10.035-16.101-2.654-9.655c-.935-3.968-1.617-7.304-1.617-11.374l11.652-15.823 6.445-2.073 15.545 2.073 6.547 5.687 9.655 22.092 15.646 34.78 24.265 47.291 7.103 14.028 3.791 12.992 1.416 3.968 2.449-.001v-2.275l1.997-26.641 3.69-32.707 3.589-42.084 1.239-11.854 5.863-14.206 11.652-7.683 9.099 4.348 7.482 10.716-1.036 6.926-4.449 28.915-8.72 45.294-5.687 30.331h3.313l3.792-3.791 15.342-20.372 25.782-32.227 11.374-12.789 13.27-14.129 8.517-6.724 16.1-.001 11.854 17.617-5.307 18.199-16.581 21.029-13.75 17.819-19.716 26.54-12.309 21.231 1.138 1.694 2.932-.278 44.536-9.479 24.062-4.347 28.714-4.928 12.992 6.066 1.416 6.167-5.106 12.613-30.71 7.583-36.018 7.204-53.636 12.689-.657.48.758.935 24.164 2.275 10.337.556h25.301l47.114 3.514 12.309 8.139 7.381 9.959-1.238 7.583-18.957 9.655-25.579-6.066-59.702-14.205-20.474-5.106-2.83-.001v1.694l17.061 16.682 31.266 28.233 39.152 36.397 1.997 8.999-5.03 7.102-5.307-.758-34.401-25.883-13.27-11.651-30.053-25.302-1.996-.001v2.654l6.926 10.136 36.574 54.975 1.895 16.859-2.653 5.485-9.479 3.311-10.414-1.895-21.408-30.054-22.092-33.844-17.819-30.331-2.173 1.238-10.515 113.261-4.929 5.788-11.374 4.348-9.478-7.204-5.03-11.652 5.03-23.027 6.066-30.052 4.928-23.886 4.449-29.674 2.654-9.858-.177-.657-2.173.278-22.37 30.71-34.021 45.977-26.919 28.815-6.445 2.553-11.173-5.789 1.037-10.337 6.243-9.2 37.257-47.392 22.47-29.371 14.508-16.961-.101-2.451h-.859l-98.954 64.251-17.618 2.275-7.583-7.103.936-11.652 3.589-3.791 29.749-20.474-.101.102.024.101z"/> </svg> );
      const UpArrowSendIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-4 h-4 text-white"> <path fillRule="evenodd" d="M12 20.25a.75.75 0 01-.75-.75V6.31l-5.47 5.47a.75.75 0 01-1.06-1.06l6.75-6.75a.75.75 0 011.06 0l6.75 6.75a.75.75 0 11-1.06 1.06l-5.47-5.47V19.5a.75.75 0 01-.75-.75z" clipRule="evenodd" /> </svg> );
      const PlusIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5"> <path fillRule="evenodd" d="M12 3.75a.75.75 0 01.75.75v6.75h6.75a.75.75 0 010 1.5h-6.75v6.75a.75.75 0 01-1.5 0v-6.75H4.5a.75.75 0 010-1.5h6.75V4.5a.75.75 0 01.75-.75z" clipRule="evenodd" /> </svg> );
      const NewRefreshIcon = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 32 32" {...props}> <path fill="currentColor" d="M 16 4 L 16 6 C 21.535156 6 26 10.464844 26 16 C 26 21.535156 21.535156 26 16 26 C 10.464844 26 6 21.535156 6 16 C 6 12.734375 7.585938 9.851563 10 8.03125 L 10 13 L 12 13 L 12 5 L 4 5 L 4 7 L 8.09375 7 C 5.59375 9.199219 4 12.417969 4 16 C 4 22.617188 9.382813 28 16 28 C 22.617188 28 28 22.617188 28 16 C 28 9.382813 22.617188 4 16 4 Z"></path> </svg> );
      const NewCloseIconSVG = (props) => ( <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 24 24" {...props} className={`inline-block ${props.className || 'w-6 h-6'}`}> <path fill="currentColor" d="M13.414,12l6.293-6.293c0.391-0.391,0.391-1.023,0-1.414s-1.023-0.391-1.414,0L12,10.586L5.707,4.293 c-0.391-0.391-1.023-0.391-1.414,0s-0.391,1.023,0,1.414L10.586,12l-6.293,6.293c-0.391-0.391-0.391,1.023,0,1.414 C4.488,19.902,4.744,20,5,20s0.512-0.098,0.707-0.293L12,13.414l6.293,6.293C18.488,19.902,18.744,20,19,20s0.512-0.098,0.707-0.293 c0.391-0.391,0.391-1.023,0-1.414L13.414,12z"/> </svg> );

      const getDomainFromUrl = (url) => {
        try { return new URL(url).hostname; } catch (e) { return null; }
      };

      const SourcesDisplay = ({ sources }) => {
          if (!sources || sources.length === 0) return null;

          const row1 = sources.slice(0, 5);
          const row2 = sources.slice(5, 10);

          const renderSourceIcon = (source, index) => {
              const domain = getDomainFromUrl(source.link);
              return (
                  <div key={source.link + index} className="relative group">
                      <a href={source.link} target="_blank" rel="noopener noreferrer" className="w-5 h-5 flex items-center justify-center bg-white border border-slate-200 rounded-full hover:bg-gray-100 transition-colors">
                          <img 
                              src={source.favicon || `https://www.google.com/s2/favicons?domain=${domain}&sz=16`}
                              alt={`${domain} favicon`}
                              className="w-3 h-3"
                              onError={(e) => { 
                                  const fallbackSibling = e.target.nextElementSibling;
                                  if (fallbackSibling) fallbackSibling.style.display = 'flex';
                                  e.target.style.display = 'none'; 
                              }}
                          />
                          <span style={{ display: 'none' }} className="w-3 h-3 items-center justify-center text-gray-400">
                              <i className="fas fa-link fa-xs"></i>
                          </span>
                      </a>
                      <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 w-max max-w-xs px-2 py-1 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none truncate">
                          {source.title}
                      </div>
                  </div>
              );
          };

          return (
              <div className="p-2.5 bg-white rounded-xl border border-slate-300/50 max-w-fit my-2 self-start ml-0 animate-scale-in-subtle space-y-2">
                  {/* Title Section */}
                  <div className="flex items-center space-x-1.5">
                       <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" className="w-3.5 h-3.5 text-text-subtle">
                           <circle cx="12" cy="12" r="10"></circle>
                           <line x1="2" y1="12" x2="22" y2="12"></line>
                           <path d="M12 2a15.3 15.3 0 0 1 4 18 15.3 15.3 0 0 1-8 0 15.3 15.3 0 0 1 4-18z"></path>
                       </svg>
                       <h3 className="text-[10px] font-semibold uppercase tracking-wider text-text-subtle">Sources</h3>
                  </div>
                  
                  {/* Icons Grid Section */}
                  <div className="flex flex-col space-y-1.5 pl-1">
                      {row1.length > 0 && (
                          <div className="flex items-center space-x-1.5">
                              {row1.map(renderSourceIcon)}
                          </div>
                      )}
                      {row2.length > 0 && (
                          <div className="flex items-center space-x-1.5">
                              {row2.map(renderSourceIcon)}
                          </div>
                      )}
                  </div>
              </div>
          );
      };

      const ChatMessageItemOptions = ({ message, onDeleteAiMessagePair, onStartEdit }) => { 
          const [showOptions, setShowOptions] = useState(false); const optionsRef = useRef(null); const [copied, setCopied] = useState(false);
          useEffect(() => { const handleClickOutside = (event) => { if (optionsRef.current && !optionsRef.current.contains(event.target) && !event.target.closest('.ai-message-options-trigger')) { setShowOptions(false); } }; document.addEventListener('mousedown', handleClickOutside); return () => document.removeEventListener('mousedown', handleClickOutside); }, []);
          const handleCopyText = () => { const textToCopy = message.finalAnswerText || message.parts?.[0]?.text || message.text || ""; if (textToCopy) { navigator.clipboard.writeText(textToCopy).then(() => { setCopied(true); setTimeout(() => setCopied(false), 1500); }).catch(err => console.error('Failed to copy text: ', err)); } setShowOptions(false); };
          const handleDelete = () => { onDeleteAiMessagePair(message.id); setShowOptions(false); };
          const handleEdit = () => { onStartEdit(message.id, message.finalAnswerText || message.text || ""); setShowOptions(false); };

          return ( <div className="relative"> <button onClick={(e) => { e.stopPropagation(); setShowOptions(prev => !prev); }} className="ai-message-options-trigger p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 focus:outline-none focus:ring-1 focus:ring-brand-primary/50" aria-label="AI Message Options"> <i className="fas fa-ellipsis-v fa-sm"></i> </button> {showOptions && ( <div ref={optionsRef} className="absolute left-0 bottom-full mb-1 w-32 bg-white border border-border-default rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-left"> <button onClick={handleCopyText} className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"> {copied ? <CheckMarkIconSVG className="w-4 h-4 mr-1.5" /> : <NewCopyIconSVG className="w-4 h-4 mr-1.5 fill-current" />} <span>{copied ? "Copied!" : "Copy"}</span> </button> <button onClick={handleEdit} className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"> <i className="fas fa-pencil-alt fa-fw mr-1.5"></i> <span>Edit</span> </button> <button onClick={handleDelete} className="w-full text-left px-2.5 py-1.5 text-xs text-red-600 hover:bg-red-500/10 rounded-md flex items-center space-x-1.5 transition-colors"> <i className="fas fa-trash-alt fa-fw mr-1.5"></i> <span>Delete</span> </button> </div> )} </div> );
      };
      
      const ChatMessageItem = ({ message, selectedUserMessageId, onSelectUserMessage, editingMessageId, editText, setEditText, onSaveEdit, onCancelEdit }) => { 
          const isUser = message.role === 'user'; const isError = message.isError === true; 
          const contentRef = useRef(null); const [userCopied, setUserCopied] = useState(false);
          const isEditing = message.id === editingMessageId;
          
          const messageLineAnimationClasses = 'animate-fade-in-up';
          
          useEffect(() => { 
            if (message.role === 'model' && !isError && !isEditing && !message.isLoading && typeof message.finalAnswerText === 'string' && message.finalAnswerText && contentRef.current) {
                const preElements = contentRef.current.querySelectorAll('pre');
                preElements.forEach(preEl => { 
                    if (preEl.parentNode && preEl.parentNode.classList.contains('code-block-wrapper')) { const codeElement = preEl.querySelector('code'); if(codeElement && !codeElement.dataset.highlighted){ hljs.highlightElement(codeElement); codeElement.dataset.highlighted = 'true'; } return;  }
                    const codeElement = preEl.querySelector('code'); if (!codeElement) return;
                    const wrapper = document.createElement('div'); wrapper.classList.add('code-block-wrapper'); wrapper.style.position = 'relative';
                    let button = preEl.querySelector('.code-copy-button');
                    if (!button) {  button = document.createElement('button'); 
                        button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`; 
                        button.classList.add( 'code-copy-button', 'absolute', 'p-1.5', 'bg-gray-100', 'hover:bg-gray-200', 'text-gray-600', 'hover:text-gray-800', 'border', 'border-gray-300', 'rounded-md', 'transition-colors', 'duration-150', 'opacity-80', 'hover:opacity-100' );
                        button.style.top = '0.35rem'; button.style.right = '0.35rem'; button.style.zIndex = '10'; button.setAttribute('aria-label', 'Copy code');
                        button.onclick = () => { if (codeElement) { navigator.clipboard.writeText(codeElement.textContent || '').then(() => { button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"></path></svg>`; button.classList.add('text-green-500'); button.classList.remove('text-gray-600', 'hover:text-gray-800'); setTimeout(() => { button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`; button.classList.remove('text-green-500'); button.classList.add('text-gray-600', 'hover:text-gray-800'); }, 2000); }).catch(err => console.error('Failed to copy: ', err)); } };
                        if (preEl.parentNode) { preEl.parentNode.insertBefore(wrapper, preEl); wrapper.appendChild(preEl); wrapper.appendChild(button); }
                    }
                    if (codeElement && !codeElement.dataset.highlighted) { hljs.highlightElement(codeElement); codeElement.dataset.highlighted = 'true'; }
                });
            }
          }, [message.finalAnswerText, message.role, message.isLoading, isError, isEditing]);
          const handleCopyUserText = (textToCopy) => { navigator.clipboard.writeText(textToCopy).then(() => { setUserCopied(true); setTimeout(() => setUserCopied(false), 1500); }).catch(err => console.error('Failed to copy text: ', err)); };
          if (message.role === 'system') { 
            const systemText = message.text || (message.parts?.[0]?.text || ""); const systemMessageStyle = isError ? "px-4 py-2 text-xs text-red-700 bg-red-100 border border-red-300 rounded-full shadow-sm italic" : "px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic"; 
            return (<div className="flex justify-center my-4"><div className={systemMessageStyle}>{isError ? <><i className="fas fa-exclamation-triangle mr-1.5"></i> {systemText}</> : systemText }</div></div>);
          }
          let bubbleBaseClasses = 'px-4 py-3 md:px-4 md:py-3 relative'; let bubbleRoleClasses = ''; let bubbleWidthClasses = ''; let contentToShow = null;
          const messageTextContent = (message.parts && message.parts[0] && typeof message.parts[0].text === 'string' ? message.parts[0].text : (typeof message.text === 'string' ? message.text : ""));
          if (isUser) { 
            bubbleRoleClasses = 'bg-surface-user-bubble-bg text-text-primary rounded-xl rounded-br-md'; bubbleWidthClasses = 'max-w-[80%] sm:max-w-[75%]'; 
            const userFilesToDisplay = message.attachedFiles || (message.uiOnlyAttachedFiles || []);
            contentToShow = ( <> {userFilesToDisplay && userFilesToDisplay.length > 0 && ( <div className={`grid gap-1 ${messageTextContent ? 'mb-1.5' : ''} ${userFilesToDisplay.filter(f => f.type?.startsWith('image/')).length > 1 ? 'grid-cols-2 sm:grid-cols-3' : 'grid-cols-1'}`}> {userFilesToDisplay.map((file, index) => { if (file.type?.startsWith('image/') && file.apiData?.data && file.apiData?.mimeType) { const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`; return ( <div key={file.id || file.name + index} className="rounded-lg overflow-hidden group relative max-w-full w-full"> <img src={imageSrc} alt={file.name || 'image preview'} className="block w-full max-h-60 object-contain rounded-lg" /> </div> ); } else if (file.type?.startsWith('text/')) { return ( <div key={file.id || file.name + index} className="bg-brand-primary/10 border border-brand-primary/20 p-2 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow-sm my-1"> <FileTextIcon className="text-brand-primary text-sm" /> <span className="truncate max-w-[120px] sm:max-w-[150px] text-text-primary font-medium"> {file.name} </span> </div> ); } return null; })} </div> )} {messageTextContent && <p className="text-base font-normal whitespace-pre-wrap break-words">{messageTextContent}</p>} </> );
          } else if (message.role === 'model') { 
              bubbleRoleClasses = `bg-white text-text-secondary rounded-xl border border-slate-200`; 
              bubbleWidthClasses = 'max-w-full w-full'; 

              if (message.showSourcesOnly) {
                  return <SourcesDisplay sources={message.sources} />;
              }

              if(isError) { 
                  bubbleRoleClasses = `bg-red-50 border border-red-300 text-red-700 rounded-xl`; 
                  const errorContent = typeof message.finalAnswerText === 'string' && message.finalAnswerText ? message.finalAnswerText : messageTextContent;
                  contentToShow = ( <div className="text-sm break-words"> <div className="flex items-center mb-1"><i className="fas fa-exclamation-triangle text-red-500 mr-2"></i><strong className="font-semibold">Error</strong></div>{errorContent.replace(/^Error:\s*/, '')} </div>); 
              
              } else if (message.isLoading && !(typeof message.finalAnswerText === 'string' && message.finalAnswerText)) { 
                  bubbleRoleClasses = ''; bubbleBaseClasses = '';
                  if (message.searchQuery) {
                      contentToShow = <SearchIndicator />;
                  } else if (message.isAnalyzing) {
                      contentToShow = <AnalyzingIndicator />;
                  } else {
                      contentToShow = <ThinkingIndicator loadingText={message.loadingText} />;
                  }
              } else { 
                  if (isEditing) {
                      contentToShow = (
                          <div>
                              <textarea
                                  value={editText}
                                  onChange={(e) => setEditText(e.target.value)}
                                  className="w-full h-48 bg-gray-50 border border-slate-200 rounded-lg p-2.5 text-sm text-text-primary focus:ring-1 focus:ring-brand-primary focus:outline-none resize-y"
                                  autoFocus
                              />
                              <div className="flex justify-end items-center space-x-2 mt-2">
                                 <button onClick={onCancelEdit} className="px-4 py-1.5 text-xs font-medium text-text-secondary bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded-md transition-colors">Cancel</button>
                                 <button onClick={() => onSaveEdit(message.id)} className="px-4 py-1.5 text-xs font-medium text-white bg-brand-primary hover:bg-brand-primary/80 border border-transparent rounded-md transition-colors">Save</button>
                              </div>
                          </div>
                      );
                  } else {
                      const textForMarkdown = (typeof message.finalAnswerText === 'string' && message.finalAnswerText) ? message.finalAnswerText : messageTextContent;
                      const isStreaming = message.isLoading && !!textForMarkdown; // Condition for blinking cursor
                      contentToShow = (
                          <div ref={contentRef}>
                              <div 
                                className={`markdown-content break-words ${isStreaming ? 'is-streaming' : ''}`} 
                                dangerouslySetInnerHTML={{ __html: marked.parse(textForMarkdown || '') }} 
                              />
                          </div>
                      );
                  }
              } 
          }
          
          return ( <div className={`flex items-start ${isUser ? 'justify-end group' : 'justify-start'} ${messageLineAnimationClasses} mb-1`}> <div className={`${bubbleBaseClasses} ${bubbleWidthClasses} ${bubbleRoleClasses}`} onClick={isUser ? () => onSelectUserMessage(message.id === selectedUserMessageId ? null : message.id) : undefined}> {contentToShow} {isUser && selectedUserMessageId === message.id && messageTextContent && ( <button onClick={(e) => { e.stopPropagation(); handleCopyUserText(messageTextContent); }} className="absolute -bottom-3 -right-1 p-1.5 bg-gray-100 text-gray-600 border border-gray-300 rounded-full shadow-md hover:bg-gray-200 transition-all" aria-label="Copy user message"> {userCopied ? <CheckMarkIconSVG className="w-4 h-4" /> : <NewCopyIconSVG className="w-4 h-4 fill-current" />} </button> )} </div> </div> );
      };
      
      const ChatInterface = ({ messages, onSendMessage, isLoading, onStopGeneration, onRegenerateLastTextMessage, onNewChat, setChatError, currentChatId, onDeleteAiMessagePair, selectedUserMessageId, setSelectedUserMessageId, editingMessageId, editText, setEditText, onSaveEdit, onCancelEdit, onStartEdit, selectedModel, setSelectedModel, setToast }) => { 
          const [inputText, setInputText] = useState(''); const [selectedFiles, setSelectedFiles] = useState([]);
          const [isModelSelectorOpen, setIsModelSelectorOpen] = useState(false);
          const modelSelectorRef = useRef(null);
          const fileInputRef = useRef(null); const messagesEndRef = useRef(null); const chatContainerRef = useRef(null); const contentEditableRef = useRef(null);
          const isAtBottomRef = useRef(true);

          useEffect(() => {
            const handleClickOutside = (event) => {
                if (modelSelectorRef.current && !modelSelectorRef.current.contains(event.target)) {
                    setIsModelSelectorOpen(false);
                }
            };
            document.addEventListener('mousedown', handleClickOutside);
            return () => {
                document.removeEventListener('mousedown', handleClickOutside);
            };
          }, []);

          useEffect(() => {
            const container = chatContainerRef.current;
            const handleScroll = () => {
                if (container) {
                    const { scrollTop, scrollHeight, clientHeight } = container;
                    isAtBottomRef.current = scrollHeight - scrollTop - clientHeight < 20;
                }
            };
            container?.addEventListener('scroll', handleScroll, { passive: true });
            return () => container?.removeEventListener('scroll', handleScroll);
          }, []);

          useEffect(() => {
            if (isAtBottomRef.current && messagesEndRef.current) {
                messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
            }
          }, [messages]);

          useEffect(() => { if (contentEditableRef.current) { contentEditableRef.current.style.height = 'auto'; const maxHeight = parseInt(getComputedStyle(contentEditableRef.current).maxHeight, 10); let newHeight = contentEditableRef.current.scrollHeight; if (maxHeight && newHeight > maxHeight) { newHeight = maxHeight; } contentEditableRef.current.style.height = `${newHeight}px`; } }, [inputText, selectedFiles]); 

          const resizeImage = (file, maxDimension = 1280, quality = 0.85) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.readAsDataURL(file);
              reader.onload = (event) => {
                const img = new Image();
                img.src = event.target.result;
                img.onload = () => {
                  const canvas = document.createElement('canvas');
                  let { width, height } = img;
                  if (width > height) {
                    if (width > maxDimension) {
                      height *= maxDimension / width;
                      width = maxDimension;
                    }
                  } else {
                    if (height > maxDimension) {
                      width *= maxDimension / height;
                      height = maxDimension;
                    }
                  }
                  canvas.width = width;
                  canvas.height = height;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, width, height);
                  const dataUrl = canvas.toDataURL(file.type === 'image/png' ? 'image/png' : 'image/jpeg', quality);
                  resolve(dataUrl.split(',')[1]);
                };
                img.onerror = reject;
              };
              reader.onerror = reject;
            });
          };

          const handleFileChange = (event) => { const files = Array.from(event.target.files); processAndSetFiles(files); if (fileInputRef.current) fileInputRef.current.value = ""; };
          const handlePaste = (event) => { const pastedText = event.clipboardData.getData('text/plain'); const pastedFiles = Array.from(event.clipboardData.files); if (pastedFiles.length > 0) { event.preventDefault(); processAndSetFiles(pastedFiles, true); } else if (pastedText && contentEditableRef.current && document.activeElement === contentEditableRef.current) { event.preventDefault(); document.execCommand('insertText', false, pastedText); setInputText(contentEditableRef.current.innerText);  } };
          
          const processAndSetFiles = (filesArray, isFromPaste = false) => { 
              if (!filesArray.length) return false;
              let filesToProcess = []; let currentTotalSize = selectedFiles.reduce((acc, curr) => acc + (curr.file?.size || 0), 0); 
              let didProcessAnyFile = false; let localErrorMessage = null; 
              
              for (const file of filesArray) {
                  const isImage = file.type.startsWith('image/'); 
                  const isTxt = file.type === 'text/plain' || (file.name && file.name.toLowerCase().endsWith('.txt')); 

                  if (!isImage && !isTxt) { if (isFromPaste) console.log(`Pasted unsupported file: ${file.name} (${file.type})`); else localErrorMessage = `File "${file.name}" (type: ${file.type}) is not supported. Only images and .txt files are allowed.`; continue; } 
                  if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { localErrorMessage = `File "${file.name}" is larger than ${MAX_FILE_SIZE_MB}MB.`; continue; } 
                  if (currentTotalSize + file.size > MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024) { localErrorMessage = `Total file size cannot exceed ${MAX_TOTAL_FILES_SIZE_MB}MB.`; break; } 
                  filesToProcess.push(file); currentTotalSize += file.size; didProcessAnyFile = true; 
              } 
              
              if(localErrorMessage){ setChatError(localErrorMessage); } else { setChatError(null); } 
              
              if (filesToProcess.length > 0) { 
                  const placeholderFiles = filesToProcess.map(file => ({ id: Date.now().toString(36) + Math.random().toString(36).substring(2) + file.name, name: file.name, type: file.type, isLoading: true, file: file, })); 
                  setSelectedFiles(prev => [...prev, ...placeholderFiles]); 
                  placeholderFiles.forEach(placeholder => { 
                      const { id, file } = placeholder; 
                      const processSingleFile = async () => { 
                          try { 
                              let apiData; 
                              if (file.type.startsWith('image/')) {
                                  const base64Data = await resizeImage(file);
                                  apiData = { mimeType: file.type, data: base64Data };
                              } else { 
                                  const textContent = await file.text(); apiData = { textContent: textContent }; 
                              } 
                              setSelectedFiles(prev => prev.map(p => p.id === id ? { ...p, isLoading: false, apiData: apiData } : p)); 
                          } catch (error) { 
                              console.error('Error processing file:', error); setChatError(`Error processing file "${file.name}".`); setSelectedFiles(prev => prev.filter(p => p.id !== id)); 
                          } 
                      }; 
                      processSingleFile(); 
                  }); 
                  return didProcessAnyFile; 
              } 
              return false; 
          };
          
          const removeSelectedFile = (fileId) => { setSelectedFiles(prev => prev.filter(f => f.id !== fileId)); };
          const handleInputFromContentEditable = () => { setInputText(contentEditableRef.current?.innerText || ''); };
          
          const handleSubmit = (e) => { 
            if(e) e.preventDefault(); 
            const currentText = contentEditableRef.current?.innerText.trim() || ''; 
            if (!currentText && selectedFiles.length === 0) return; 
            setChatError(null); 
            onSendMessage(currentText, selectedFiles); 
            
            setTimeout(() => {
                if(contentEditableRef.current) contentEditableRef.current.innerText = ''; 
                setInputText(''); 
                setSelectedFiles([]);
            }, 50);
          };

          const handleContentEditableKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { const isLikelyDesktop = window.innerWidth > 768; if (isLikelyDesktop) { e.preventDefault(); if (!isSendButtonActuallyDisabled) { handleSubmit(e); } } } };
          const isAiCurrentlyProcessing = messages.some(m => m.role === 'model' && m.isLoading);
          const currentInputTextFromEditable = contentEditableRef.current?.innerText?.trim() || '';
          const isSendButtonActuallyDisabled = (!isAiCurrentlyProcessing && (isLoading || (currentInputTextFromEditable === '' && selectedFiles.length === 0) || selectedFiles.some(f => f.isLoading))); 
          const sendOrStopButtonBaseClasses = "w-8 h-8 flex items-center justify-center font-semibold rounded-full transition-all duration-150 ease-in-out transform active:animate-button-press focus:outline-none";
          let sendOrStopButtonDynamicClasses = isAiCurrentlyProcessing ? "bg-slate-500 hover:bg-slate-600 text-white" : (isSendButtonActuallyDisabled ? "bg-brand-send-active opacity-60 text-white cursor-not-allowed" : "bg-brand-send-active hover:bg-brand-send-hover text-white focus:ring-2 focus:ring-offset-1 focus:ring-brand-send-active/50");
          
          useEffect(() => { 
              if (contentEditableRef.current) { contentEditableRef.current.innerText = ''; } 
              setInputText(''); 
              setSelectedFiles([]); 
          }, [currentChatId]); 

          const activeMessages = messages.filter(m => (m.role !== 'system' || m.isError) && m.id !== 'loading_chat_indicator');

          return ( <div className="w-full h-full flex flex-col bg-white md:rounded-xl shadow-chat-window overflow-hidden"> <header className="p-3 flex items-center justify-between flex-shrink-0 bg-white border-b border-border-light shadow-header"> <h1 className="text-xl font-sans font-semibold text-gray-800 text-left flex-grow">AlphaGPT</h1> <button onClick={() => { onNewChat(); setSelectedUserMessageId(null); }} className="p-1.5 text-text-secondary hover:text-brand-primary rounded-full hover:bg-interactive-hover/70 transition-colors focus:outline-none" aria-label="New Chat" disabled={isLoading || isAiCurrentlyProcessing} > <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6"> <path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zM12.75 9a.75.75 0 00-1.5 0v2.25H9a.75.75 0 000 1.5h2.25V15a.75.75 0 001.5 0v-2.25H15a.75.75 0 000-1.5h-2.25V9z" clipRule="evenodd" /> </svg> </button> </header> <div ref={chatContainerRef} className="flex-grow p-4 md:p-5 space-y-3 md:space-y-4 overflow-y-auto chat-messages-container relative bg-surface-chat-area"> 
            { activeMessages.length === 0 && !isLoading ? ( 
              <div className="absolute inset-0 flex flex-col items-center justify-center text-center pointer-events-none p-8 animate-fade-in-up opacity-0" style={{animationDelay: '0.2s', animationFillMode: 'forwards'}}> 
                <NewEmptyStateIconSVG className="w-16 h-16 mb-5 text-brand-send-active" /> 
                <p className="text-2xl lg:text-3xl font-serif text-gray-800 leading-tight"> How can I help you<br />today? </p> 
              </div> 
            ) : null }
              {messages.map((msg, idx) => { 
                  const isThisMessageAiAndFinalized = msg.role === 'model' && !msg.isLoading && !msg.isError && 
                                                   ( (typeof msg.finalAnswerText === 'string' && msg.finalAnswerText) );
                  
                  let isEffectivelyLastAiMessageForButtons = false;
                  if (isThisMessageAiAndFinalized) {
                      isEffectivelyLastAiMessageForButtons = true; 
                      for (let k = idx + 1; k < messages.length; k++) {
                          const nextMsg = messages[k];
                          if (nextMsg.role === 'system' || (nextMsg.role === 'model' && nextMsg.isLoading)) continue;
                          if (nextMsg.role === 'user') {
                              isEffectivelyLastAiMessageForButtons = false;
                              break;
                          }
                          if (nextMsg.role === 'model' && !nextMsg.isLoading && !nextMsg.isError) {
                               isEffectivelyLastAiMessageForButtons = false;
                               break;
                          }
                      }
                  }

                  let canThisAiMessageBeRegenerated = false;
                  if(isEffectivelyLastAiMessageForButtons) { 
                      let userPromptIndex = -1;
                      for(let i = idx - 1; i >= 0; i--) { 
                          if (messages[i].role === 'user') { 
                              let interveningUserMessageBetweenThisAiAndItsUserPrompt = false; 
                              for (let j = i + 1; j < idx; j++) { 
                                  if (messages[j].role === 'user') { 
                                      interveningUserMessageBetweenThisAiAndItsUserPrompt = true; break; 
                                  } 
                              } 
                              if (!interveningUserMessageBetweenThisAiAndItsUserPrompt) { 
                                  userPromptIndex = i; break; 
                              } 
                          } 
                      }
                      canThisAiMessageBeRegenerated = userPromptIndex !== -1;
                  }

                  return ( <React.Fragment key={msg.id}> {((msg.role === 'user' && ( (msg.parts && msg.parts[0]?.text) || msg.text || msg.attachedFiles?.length > 0 || msg.uiOnlyAttachedFiles?.length > 0)) || (msg.role === 'model') || msg.role === 'system' || msg.isError) && ( <div> <ChatMessageItem message={msg} selectedUserMessageId={selectedUserMessageId} onSelectUserMessage={setSelectedUserMessageId} editingMessageId={editingMessageId} editText={editText} setEditText={setEditText} onSaveEdit={onSaveEdit} onCancelEdit={onCancelEdit} /> </div> )} 
                  {isEffectivelyLastAiMessageForButtons && msg.id !== editingMessageId && ( 
                    <div className={`flex items-center space-x-2 mt-1 ml-0 justify-start mb-2`}> 
                      {canThisAiMessageBeRegenerated && ( <button onClick={() => { setChatError(null); onRegenerateLastTextMessage(msg.id); setSelectedUserMessageId(null); }} className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 group focus:outline-none focus:ring-1 focus:ring-brand-primary/50" aria-label="Regenerate response" disabled={isLoading || isAiCurrentlyProcessing} > <NewRefreshIcon className="w-5 h-5 transition-transform duration-200" /> </button> )} 
                      <ChatMessageItemOptions message={msg} onDeleteAiMessagePair={onDeleteAiMessagePair} onStartEdit={onStartEdit} /> 
                    </div> 
                  )} 
                  </React.Fragment> )
              })} <div ref={messagesEndRef} className="h-1" /> </div> 
              <form onSubmit={handleSubmit} className="bg-surface-chat-area flex-shrink-0"> 
                <div className="p-2 md:p-3"> 
                  <div 
                    className="flex flex-col bg-white rounded-2xl p-2.5 border border-slate-200 shadow-[0_2px_4px_rgba(0,0,0,0.05)] focus-within:border-slate-300 focus-within:shadow-[0_4px_8px_rgba(0,0,0,0.07)] transition-all duration-200 ease-in-out"
                    onClick={(e) => { if (contentEditableRef.current && !contentEditableRef.current.contains(e.target) && e.target.tagName !== 'BUTTON' && !e.target.closest('button') && !e.target.closest('[aria-label="Attach file"]') && !e.target.closest('.relative') ) { contentEditableRef.current.focus(); } }} > 
                    {selectedFiles.some(f => f.type.startsWith('image/')) && ( <div className="image-preview-container-input"> {selectedFiles.filter(f => f.type.startsWith('image/')).map(file => ( <div key={file.id} className="relative w-14 h-14 rounded-md overflow-hidden shadow-sm group border border-gray-200"> {file.isLoading ? ( <div className="w-full h-full flex items-center justify-center bg-gray-100"> <div className="w-4 h-4 border-2 border-gray-300 border-t-brand-primary rounded-full animate-spin"></div> </div> ) : ( <img src={`data:${file.apiData.mimeType};base64,${file.apiData.data}`} alt={file.name} className="w-full h-full object-cover" /> )} <button type="button" onClick={() => removeSelectedFile(file.id)} className="absolute top-0.5 right-0.5 w-5 h-5 bg-black/50 hover:bg-black/70 text-white rounded-full flex items-center justify-center transition-opacity focus:outline-none opacity-100" aria-label="Remove image" > <NewCloseIconSVG className="w-3 h-3"/> </button> </div> ))} </div> )} {selectedFiles.some(f => !f.type.startsWith('image/')) && ( <div className={`file-pill-container ${selectedFiles.some(f => f.type.startsWith('image/')) ? 'mt-1.5' : ''}`}> {selectedFiles.filter(f => !f.type.startsWith('image/')).map(file => ( <div key={file.id} className="file-pill"> {file.isLoading ? <div className="w-3 h-3 border-2 border-gray-300 border-t-brand-primary rounded-full animate-spin mr-1.5"></div> : <FileTextIcon className="file-pill-icon"/>} <span className="file-pill-name">{file.name}</span> <button type="button" onClick={() => removeSelectedFile(file.id)} className="file-pill-remove"> <i className="fas fa-times"></i> </button> </div> ))} </div> )} <div ref={contentEditableRef} contentEditable={!(isLoading || isAiCurrentlyProcessing)} onInput={handleInputFromContentEditable} onPaste={handlePaste} onKeyDown={handleContentEditableKeyDown} data-placeholder={"Ask AlphaGPT..."} className={`content-editable-input w-full flex-1 text-sm md:text-[15px] focus:outline-none resize-none overflow-y-auto relative`} style={{ maxHeight: '100px', minHeight: '40px' }} suppressContentEditableWarning={true} > </div> 
                     <div className="flex justify-between items-end w-full pt-2.5 mt-auto">
                        <div className="flex items-center space-x-2">
                           <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" multiple accept="image/*,.txt,text/plain" disabled={isLoading || isAiCurrentlyProcessing} />
                           <button type="button" onClick={() => fileInputRef.current?.click()} className="w-8 h-8 flex items-center justify-center text-gray-500 hover:text-gray-700 rounded-full hover:bg-gray-200/70 border border-gray-300 transition-colors duration-150 disabled:opacity-50 flex-shrink-0 focus:outline-none" aria-label="Attach file" disabled={isLoading || isAiCurrentlyProcessing}>
                              <PlusIcon />
                           </button>
                        </div>
                        <div className="flex items-end space-x-2">
                            <div ref={modelSelectorRef} className="relative">
                              <button type="button" onClick={() => setIsModelSelectorOpen(prev => !prev)} disabled={isLoading || isAiCurrentlyProcessing} className="flex items-center space-x-1.5 h-7 px-2.5 text-xs font-medium text-gray-600 bg-white border border-slate-200 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50 focus:outline-none">
                                 <span>{CONFIG.models.list.find(m => m.id === selectedModel)?.uiName || 'Model'}</span>
                                 <i className="fas fa-chevron-down fa-2xs text-gray-500"></i>
                              </button>
                              {isModelSelectorOpen && (
                                <div className="absolute bottom-full right-0 mb-2 w-36 bg-white border border-border-default rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-right">
                                    {CONFIG.models.list.map(model => (
                                        <button key={model.id} onClick={() => { setSelectedModel(model.id); setIsModelSelectorOpen(false); }} className={`w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center space-x-2 transition-colors ${selectedModel === model.id ? 'font-semibold text-brand-primary bg-interactive-hover/70' : 'text-text-secondary hover:bg-interactive-hover/70'}`}>
                                            <span>{model.uiName}</span>
                                        </button>
                                    ))}
                                </div>
                              )}
                           </div>
                           <button type={isAiCurrentlyProcessing ? "button" : "submit"} onClick={isAiCurrentlyProcessing ? onStopGeneration : undefined} disabled={isSendButtonActuallyDisabled} className={`${sendOrStopButtonBaseClasses} ${sendOrStopButtonDynamicClasses}`} style={{ overflow: 'hidden' }} aria-label={isAiCurrentlyProcessing ? "Stop generation" : "Send message"}>
                                {isAiCurrentlyProcessing ? ( <i className="fas fa-stop text-sm"></i> ) : ( <UpArrowSendIcon /> )}
                           </button>
                        </div>
                     </div>
                  </div> 
                </div> 
              </form> 
            </div> 
          );
      };
      
      const Toast = ({ message, type = 'info', onDismiss }) => {
        const baseClasses = "flex items-center p-3 space-x-2.5 rounded-lg shadow-lg max-w-[90vw] sm:max-w-sm";
        const typeClasses = {
            info: 'text-gray-600 bg-white border border-gray-200',
            error: 'text-red-700 bg-red-100 border border-red-200',
            success: 'text-green-700 bg-green-100 border border-green-200',
        };
        const iconClasses = {
            info: 'fa-info-circle text-blue-500',
            error: 'fa-exclamation-triangle text-red-500',
            success: 'fa-check-circle text-green-500',
        };

        return (
            <div className={`${baseClasses} ${typeClasses[type]} animate-fade-in-up`} role="alert">
                <i className={`fas ${iconClasses[type]} flex-shrink-0 w-5 h-5`}></i>
                <span className="text-xs font-medium">{message}</span>
                <button onClick={onDismiss} className="p-1.5 -m-1.5 ml-auto text-gray-400 hover:text-gray-900 rounded-lg hover:bg-gray-100/50 focus:outline-none focus:ring-2 focus:ring-gray-300 flex-shrink-0">
                    <NewCloseIconSVG className="w-3.5 h-3.5" />
                </button>
            </div>
        );
      };
      
      const App = () => { 
          const [currentUser, setCurrentUser] = useState({ uid: 'guest_user', email: 'Guest User' }); const [authLoading, setAuthLoading] = useState(false); const [chatMessages, setChatMessages] = useState([]); const [isChatLoading, setIsChatLoading] = useState(false); const [chatError, setChatError] = useState(null); const [currentChatId, setCurrentChatId] = useState('session_chat_init');
          const [selectedUserMessageId, setSelectedUserMessageId] = useState(null);
          const [editingMessageId, setEditingMessageId] = useState(null);
          const [editText, setEditText] = useState('');
          const [selectedModel, setSelectedModel] = useState(CONFIG.models.default);
          const [toast, setToast] = useState(null);
          const isStoppingGenerationRef = useRef(false); const streamTextBuffer = useRef(""); 

          useEffect(() => {
              document.documentElement.style.setProperty('--shimmer-duration', `${CONFIG.settings.shimmerSpeedSeconds}s`);
          }, []);

          useEffect(() => {
            if (toast) {
                const timer = setTimeout(() => setToast(null), 4000);
                return () => clearTimeout(timer);
            }
          }, [toast]);

          useEffect(() => { if (chatError) { const errorId = Date.now() + '_sys_validation_err'; const newErrorMsg = {id: errorId, role: 'system', text: chatError, isError: true, timestamp: new Date().getTime()}; setChatMessages(prev => { const lastMessage = prev[prev.length -1]; if(lastMessage && lastMessage.id.includes('_sys_validation_err') && lastMessage.text === chatError) return prev; return [...prev, newErrorMsg]; }); } }, [chatError]); 
          const handleNewChat = useCallback(() => { const newSessionId = 'session_chat_' + Date.now().toString(36) + Math.random().toString(36).substring(2); setCurrentChatId(newSessionId); setChatMessages([]); setChatError(null); return newSessionId; }, []); 
          
          const getA4fHistory = (currentMessagesFromState) => {
            const openAiMessages = currentMessagesFromState
                .filter(msg => !(
                    msg.role === 'system' ||
                    (msg.role === 'model' && msg.isLoading && !(typeof msg.finalAnswerText === 'string' && msg.finalAnswerText)) ||
                    msg.isError || msg.showSourcesOnly
                ))
                .map(msg => {
                    const role = msg.role === 'model' ? 'assistant' : msg.role;
                    let content;

                    if (role === 'user') {
                        let textParts = (msg.parts || []).filter(p => p.text).map(p => p.text).join(' ').trim();
                        if (!textParts && msg.text) {
                            textParts = msg.text.trim();
                        }

                        const filesToConsider = msg.uiOnlyAttachedFiles || msg.attachedFiles || [];

                        const textFilesContent = filesToConsider
                            .filter(file => (file.name?.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent)
                            .map(file => `\n[Content of attached file: ${file.name}]\n${file.apiData.textContent}\n[End of file: ${file.name}]\n`)
                            .join('');

                        const fullText = (textParts + textFilesContent).trim();

                        const images = filesToConsider
                            .filter(file => file.type.startsWith('image/') && file.apiData?.mimeType && file.apiData?.data)
                            .map(file => ({
                                type: 'image_url',
                                image_url: { url: `data:${file.apiData.mimeType};base64,${file.apiData.data}` }
                            }));

                        if (images.length > 0) {
                            content = [{ type: 'text', text: fullText }];
                            content.push(...images);
                        } else {
                            content = fullText;
                        }
                    } else { // assistant
                        content = msg.finalAnswerText || msg.text || (msg.parts?.[0]?.text || "");
                    }

                    if (!content || (Array.isArray(content) && content.length === 0) || (typeof content === 'string' && !content.trim())) {
                        return null;
                    }

                    return { role, content };
                })
                .filter(Boolean);

            const firstUserIndex = openAiMessages.findIndex(m => m.role === 'user');
            if (firstUserIndex > 0) {
                return openAiMessages.slice(firstUserIndex);
            }
            if (openAiMessages.length === 1 && openAiMessages[0].role === 'assistant'){
                return [];
            }
            return openAiMessages;
          };
          
          const handleStopGeneration = useCallback(() => {
              isStoppingGenerationRef.current = true;
          }, []); 

          const addMessageToLocalChat = async (role, text, filesForDisplay, aiSpecificData = {}) => { const messageId = Date.now().toString(36) + Math.random().toString(36).substring(2); const messagePartsForDisplay = []; if (text) messagePartsForDisplay.push({ text: text }); const attachedFilesForLocalState = filesForDisplay.map(f => ({ id: f.id, name: f.name, type: f.type, apiData: f.apiData, isLoading: f.isLoading })); const messageData = { id: messageId, role: role, parts: messagePartsForDisplay.length > 0 ? messagePartsForDisplay : [{text: ""}], text: text || "", timestamp: new Date().getTime(), ...(role === 'user' && attachedFilesForLocalState.length > 0 && { uiOnlyAttachedFiles: attachedFilesForLocalState }), ...(role === 'model' && aiSpecificData.modelUsed && { modelUsed: aiSpecificData.modelUsed }), ...(aiSpecificData.searchUsed && { searchUsed: true })}; setChatMessages(prev => [...prev, messageData]); return messageId; };
          
          const performSerperSearch = async (query) => {
              try {
                  const response = await fetch("https://google.serper.dev/search", {
                      method: "POST",
                      headers: {
                          'X-API-KEY': CONFIG.api.serper.apiKey,
                          'Content-Type': 'application/json'
                      },
                      body: JSON.stringify({
                          q: query,
                          num: 10
                      }),
                  });
                  if (!response.ok) {
                      const errorData = await response.json();
                      throw new Error(errorData.message || `Serper API failed with status ${response.status}`);
                  }
                  const data = await response.json();
                  if (!data.organic || data.organic.length === 0) {
                      return { toolContent: "No results found.", sources: [] };
                  }
                  const sources = data.organic.map(item => ({
                      link: item.link, 
                      title: item.title, 
                      snippet: item.snippet,
                      favicon: item.favicon
                  }));
                  const toolContent = JSON.stringify(sources.map(s => ({ title: s.title, link: s.link, snippet: s.snippet })));
                  return { toolContent, sources };
              } catch (error) {
                  console.error("Serper Search Error:", error);
                  return { toolContent: `Search failed with error: ${error.message}`, sources: [] };
              }
          };

          const simulateTypingEffect = async (targetAiMessageUiId, fullText) => {
              streamTextBuffer.current = "";
              for (const char of fullText) {
                  if (isStoppingGenerationRef.current) break;
                  streamTextBuffer.current += char;
                  setChatMessages(prev => prev.map(msg => 
                      msg.id === targetAiMessageUiId 
                      ? { ...msg, isLoading: true, loadingText: '', finalAnswerText: streamTextBuffer.current, text: streamTextBuffer.current, parts: [{ text: streamTextBuffer.current }] } 
                      : msg
                  ));
                  await new Promise(resolve => setTimeout(resolve, CONFIG.settings.streamingSpeedMs));
              }
          };

          const _streamAiResponse = async (targetAiMessageUiId, historyForA4f, modelToUse) => {
              isStoppingGenerationRef.current = false;
              setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, loadingText: "Thinking..." } : m));
              
              const initialHistory = [{ role: 'system', content: getSystemInstruction() }, ...historyForA4f];

              try {
                  const initialResponse = await fetch(CONFIG.api.a4f.baseUrl, {
                      method: 'POST',
                      headers: { 'Authorization': `Bearer ${CONFIG.api.a4f.apiKey}`, 'Content-Type': 'application/json' },
                      body: JSON.stringify({ model: modelToUse, messages: initialHistory, stream: CONFIG.settings.stream, temperature: CONFIG.settings.temperature }),
                  });
                  
                  if (!initialResponse.ok) {
                    const errorBody = await initialResponse.json().catch(()=>({}));
                    throw new Error(`Request failed with status ${initialResponse.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
                  }
                  
                  const initialData = await initialResponse.json();
                  const initialContent = initialData.choices?.[0]?.message?.content || "";
                  
                  let finalAnswerText = "";
                  const searchMatch = initialContent.match(/\[SEARCH: "([^"]+)"\]/);
                  
                  if (searchMatch && searchMatch[1]) {
                      const searchQuery = searchMatch[1];
                      setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, searchQuery: searchQuery, loadingText: null } : m));
                      
                      const { toolContent, sources } = await performSerperSearch(searchQuery);

                      setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, sources: sources, showSourcesOnly: true, searchQuery: null } : m));
                      
                      await new Promise(resolve => setTimeout(resolve, 1500));
                      if(isStoppingGenerationRef.current) throw new Error("Generation stopped");

                      setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? {...m, showSourcesOnly: false, isAnalyzing: true, isLoading: true} : m));
                      await new Promise(resolve => setTimeout(resolve, 1000));
                      if(isStoppingGenerationRef.current) throw new Error("Generation stopped");

                      const finalHistory = [
                          ...initialHistory,
                          { role: 'assistant', content: initialContent },
                          { role: 'user', content: `Okay, I have the search results for "${searchQuery}". Please use this information to answer my original question. Do not mention the search process or the command format, just provide the answer directly in Roman Urdu. Here are the results:\n\n${toolContent}` }
                      ];
                      
                      const finalResponse = await fetch(CONFIG.api.a4f.baseUrl, {
                          method: 'POST',
                          headers: { 'Authorization': `Bearer ${CONFIG.api.a4f.apiKey}`, 'Content-Type': 'application/json' },
                          body: JSON.stringify({ model: modelToUse, messages: finalHistory, stream: CONFIG.settings.stream, temperature: CONFIG.settings.temperature }),
                      });

                      if (!finalResponse.ok) throw new Error("Final answer request failed");
                      const finalData = await finalResponse.json();
                      finalAnswerText = finalData.choices?.[0]?.message?.content || "Sorry, I couldn't process the search results.";

                  } else {
                      finalAnswerText = initialContent;
                  }

                  // Clear indicators and start typing effect
                  setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isAnalyzing: false, showSourcesOnly: false, searchQuery: null } : m));
                  await simulateTypingEffect(targetAiMessageUiId, finalAnswerText);

              } catch (err) {
                  if (err.message !== "Generation stopped") {
                    console.error("AI stream error:", err);
                    let errorTextForUser = `A network error occurred. Please check your connection and try again. (${err.message})`;
                    setToast({ text: errorTextForUser, type: 'error' });
                    setChatMessages(prev => prev.map(msg => msg.id === targetAiMessageUiId ? { ...msg, isLoading: false, isError: true, finalAnswerText: errorTextForUser, text: errorTextForUser, parts: [{text: errorTextForUser}], sources: null, showSourcesOnly: false } : msg ));
                  }
              } finally {
                  if (isStoppingGenerationRef.current) {
                      streamTextBuffer.current += "\n\n*Generation stopped by user.*";
                  }
                  setChatMessages(prev => prev.map(msg => msg.id === targetAiMessageUiId ? { ...msg, isLoading: false, isAnalyzing: false, finalAnswerText: streamTextBuffer.current.trim(), text: streamTextBuffer.current.trim(), parts: [{text: streamTextBuffer.current.trim()}], showSourcesOnly: false } : msg ));
                  isStoppingGenerationRef.current = false;
              }
          };

          const handleSendChatMessage = useCallback(async (messageText, filesToSendFromInput) => { 
              if (!messageText.trim() && filesToSendFromInput.length === 0) return; 
              if (filesToSendFromInput.some(f => f.isLoading)) { setChatError("Please wait for all files to finish loading."); return; }
              setChatError(null); 
              setIsChatLoading(true);
              
              const tempUserMessage = {
                id: 'temp_user_' + Date.now(),
                role: 'user',
                text: messageText,
                parts: messageText ? [{ text: messageText }] : [],
                timestamp: new Date().getTime(),
                uiOnlyAttachedFiles: filesToSendFromInput,
              };
              const historyForA4f = getA4fHistory([...chatMessages, tempUserMessage]);

              await addMessageToLocalChat('user', messageText, filesToSendFromInput); 
              
              const aiPlaceholderUiId = Date.now().toString() + '_model_resp_temp_ui'; 
              
              const preliminaryAiPlaceholder = { 
                  id: aiPlaceholderUiId, role: 'model', text: '', parts: [{text:''}], finalAnswerText: "",
                  timestamp: new Date().getTime(), isLoading: true, isError: false, sources: null, showSourcesOnly: false,
                  modelUsed: selectedModel, searchUsed: true, searchQuery: null, isAnalyzing: false,
              }; 
              setChatMessages(prev => [ ...prev.filter(m => m.id !== 'loading_chat_indicator'), preliminaryAiPlaceholder ]); 
              
              await _streamAiResponse(aiPlaceholderUiId, historyForA4f, selectedModel); 
              setIsChatLoading(false);
          }, [chatMessages, currentChatId, selectedModel]); 

          const handleRegenerateLastTextMessage = useCallback(async (aiMessageIdToRegenerate) => {
              setChatError(null);
              setIsChatLoading(true);

              const messagesSnapshot = [...chatMessages];
              let userPromptIndex = -1;
              const aiMessageIndex = messagesSnapshot.findIndex(m => m.id === aiMessageIdToRegenerate);

              if (aiMessageIndex === -1) { setToast({ text: "Cannot regenerate: Original AI message not found.", type: 'error' }); setIsChatLoading(false); return; }
              const modelUsedForOriginal = messagesSnapshot[aiMessageIndex].modelUsed || selectedModel;

              for (let i = aiMessageIndex - 1; i >= 0; i--) {
                  if (messagesSnapshot[i].role === 'user') {
                      userPromptIndex = i;
                      break;
                  }
              }

              if (userPromptIndex === -1) { setToast({ text: "Cannot regenerate: Original user prompt not found.", type: 'error' }); setIsChatLoading(false); return; }

              const historyForApi = getA4fHistory(messagesSnapshot.slice(0, userPromptIndex + 1));
              
              const newAiMessageId = Date.now().toString() + '_model_regen_ui';

              setChatMessages(prev => prev.map(msg => 
                  msg.id === aiMessageIdToRegenerate 
                  ? {
                      id: newAiMessageId,
                      role: 'model', text: '', parts: [{text: ''}], finalAnswerText: "",
                      timestamp: new Date().getTime(), isLoading: true,
                      isError: false, sources: null, modelUsed: modelUsedForOriginal, searchUsed: true,
                      showSourcesOnly: false, searchQuery: null, isAnalyzing: false,
                    }
                  : msg
              ));
              
              await _streamAiResponse(newAiMessageId, historyForApi, modelUsedForOriginal);
              setIsChatLoading(false);
          }, [chatMessages, currentChatId, selectedModel]); 

          const handleDeleteAiMessagePair = async (aiMessageId) => { const currentMessages = [...chatMessages]; const aiMessageIndex = currentMessages.findIndex(msg => msg.id === aiMessageId); if (aiMessageIndex === -1) { setToast({ text: "Could not find the AI message to delete.", type: 'error' }); return; } let idsToDelete = [aiMessageId]; if (aiMessageIndex > 0) { let precedingUserMessage = null; for (let i = aiMessageIndex - 1; i >= 0; i--) { if (currentMessages[i].role === 'model') { break; } if (currentMessages[i].role === 'user') { let interveningUserMessage = false; for (let k = i + 1; k < aiMessageIndex; k++) { if (currentMessages[k].role === 'user') { interveningUserMessage = true; break; } } if (!interveningUserMessage) { precedingUserMessage = currentMessages[i]; } break; } } if (precedingUserMessage) { idsToDelete.push(precedingUserMessage.id); } } setChatMessages(prev => prev.filter(msg => !idsToDelete.includes(msg.id))); };
          const handleStartEdit = (id, currentText) => { setEditingMessageId(id); setEditText(currentText || ''); };
          const handleCancelEdit = () => { setEditingMessageId(null); setEditText(''); };
          const handleSaveEdit = (id) => { setChatMessages(prev => prev.map(msg => msg.id === id ? { ...msg, finalAnswerText: editText, text: editText, parts: [{ text: editText }] } : msg)); handleCancelEdit(); };

          if (authLoading) { return ( <div className="h-full flex items-center justify-center bg-surface-main"> <div className="w-10 h-10 border-4 border-brand-primary border-t-transparent rounded-full animate-spin-continuous"></div> </div> ); }
          return ( 
            <div className="h-full text-text-primary flex font-sans bg-surface-main relative">
                {toast && (
                    <div className="absolute top-5 left-1/2 -translate-x-1/2 z-50">
                        <Toast message={toast.text} type={toast.type} onDismiss={() => setToast(null)} />
                    </div>
                )}
                <div className="flex-grow h-full flex flex-col min-w-0">
                    <ChatInterface 
                        messages={chatMessages} 
                        onSendMessage={handleSendChatMessage} 
                        isLoading={isChatLoading} 
                        onStopGeneration={handleStopGeneration} 
                        onRegenerateLastTextMessage={handleRegenerateLastTextMessage} 
                        onNewChat={handleNewChat} 
                        setChatError={setChatError} 
                        currentChatId={currentChatId} 
                        onDeleteAiMessagePair={handleDeleteAiMessagePair} 
                        selectedUserMessageId={selectedUserMessageId} 
                        setSelectedUserMessageId={setSelectedUserMessageId} 
                        editingMessageId={editingMessageId} 
                        editText={editText} 
                        setEditText={setEditText} 
                        onSaveEdit={handleSaveEdit} 
                        onCancelEdit={handleCancelEdit} 
                        onStartEdit={handleStartEdit} 
                        selectedModel={selectedModel} 
                        setSelectedModel={setSelectedModel} 
                        setToast={setToast} 
                    /> 
                </div> 
            </div> 
          );
      };
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>
