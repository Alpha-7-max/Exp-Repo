
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlphaGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',
              'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',
              'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',
              'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',
              'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',
              'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',
              'surface-bubble-ai':
                'rgb(var(--surface-bubble-ai) / <alpha-value>)',
              'surface-chat-area':
                'rgb(var(--surface-chat-area) / <alpha-value>)',
              'surface-user-bubble-bg':
                'rgb(var(--surface-user-bubble-bg-val) / <alpha-value>)',
              'border-user-bubble-color':
                'rgb(var(--border-user-bubble-color-val) / <alpha-value>)',
              'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',
              'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',
              'text-on-primary': 'rgb(var(--text-on-primary) / <alpha-value>)',
              'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',
              'text-button-icon':
                'rgb(var(--text-button-icon) / <alpha-value>)',
              'link-blue': '#60A5FA',
              'link-blue-hover': '#93C5FD',
              'border-default': 'rgb(var(--border-default) / <alpha-value>)',
              'border-light': 'rgb(var(--border-light) / <alpha-value>)',
              'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
              'interactive-hover':
                'rgb(var(--interactive-hover) / <alpha-value>)',
              'focus-ring-color':
                'rgb(var(--focus-ring-color) / <alpha-value>)',
              'status-info': 'rgb(var(--status-info) / <alpha-value>)',
              'status-success': 'rgb(var(--status-success) / <alpha-value>)',
              'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
              'status-error': 'rgb(var(--status-error) / <alpha-value>)',
              'error-fg': 'rgb(var(--error-fg) / <alpha-value>)',
              // <-- CHANGED: Send button colors are now blue
              'brand-send-active': 'rgb(var(--brand-primary) / 1)',
              'brand-send-hover': '#60A5FA',
            },
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
              poppins: ['Poppins', 'sans-serif'],
              roboto: ['Roboto', 'sans-serif'],
              serif: ['Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'],
              outfit: ['Outfit', 'sans-serif'],
              lato: ['Lato', 'sans-serif'],
              'open-sans': ['"Open Sans"', 'sans-serif'],
              montserrat: ['Montserrat', 'sans-serif'],
              'source-sans-pro': ['"Source Sans Pro"', 'sans-serif'],
              nunito: ['Nunito', 'sans-serif'],
              raleway: ['Raleway', 'sans-serif'],
              merriweather: ['Merriweather', 'serif'],
              'playfair-display': ['"Playfair Display"', 'serif'],
              ubuntu: ['Ubuntu', 'sans-serif'],
              'josefin-sans': ['"Josefin Sans"', 'sans-serif'],
            },
            animation: {
              'fade-in-up': 'fadeInUp 0.5s ease-out forwards',
              'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
              'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out',
              'button-press': 'buttonPress 0.2s ease-out',
              rippleOut: 'rippleOut 2.5s infinite ease-out',
              'speak-bob': 'speakBob 0.7s ease-in-out',
              'think-glance': 'thinkGlance 2s infinite ease-in-out',
              blink: 'blink 4s infinite ease-in-out',
              'happy-bounce': 'happyBounce 0.5s ease-out',
              'empty-state-glow':
                'emptyStateGlow 3.5s infinite alternate ease-in-out',
              'modal-fade-in': 'modal-fade-in 0.3s ease-out forwards',
              'modal-fade-out': 'modal-fade-out 0.3s ease-in forwards',
              'spin-continuous': 'spinContinuous 2s linear infinite',
              'shimmer-animation':
                'shimmer-animation var(--shimmer-duration) linear infinite',
              'cursor-blink': 'cursor-blink 1.2s infinite steps(1)',
            },
            keyframes: {
              fadeInUp: {
                '0%': { opacity: '0', transform: 'translateY(10px)' },
                '100%': { opacity: '1', transform: 'translateY(0)' },
              },
              scaleInSubtle: {
                '0%': { opacity: '0.5', transform: 'scale(0.95)' },
                '100%': { opacity: '1', transform: 'scale(1)' },
              },
              pulseGentle: {
                '0%, 100%': { transform: 'scale(1)', opacity: '0.8' },
                '50%': { transform: 'scale(1.015)', opacity: '1' },
              },
              buttonPress: {
                '0%': { transform: 'scale(1)' },
                '50%': { transform: 'scale(0.96)' },
                '100%': { transform: 'scale(1)' },
              },
              emptyStateGlow: {
                '0%': {
                  filter:
                    'drop-shadow(0 0 4px rgba(var(--brand-primary), 0.3)) drop-shadow(0 0 8px rgba(var(--brand-secondary), 0.2))',
                },
                '100%': {
                  filter:
                    'drop-shadow(0 0 8px rgba(var(--brand-primary), 0.4)) drop-shadow(0 0 16px rgba(var(--brand-secondary), 0.25))',
                },
              },
              rippleOut: {
                '0%': { transform: 'scale(0.8)', opacity: '0.3' },
                '70%': { opacity: '0.1' },
                '100%': { transform: 'scale(2.0)', opacity: '0' },
              },
              speakBob: {
                '0%, 100%': { transform: 'translateY(0) scale(1)' },
                '50%': { transform: 'translateY(-2px) scale(1.05)' },
              },
              thinkGlance: {
                '0%, 100%': { transform: 'translateX(0px)' },
                '25%': { transform: 'translateX(-1px)' },
                '75%': { transform: 'translateX(1px)' },
              },
              blink: {
                '0%, 90%, 100%': { transform: 'scaleY(1)' },
                '95%': { transform: 'scaleY(0.1)' },
              },
              'cursor-blink': {
                '0%, 100%': { opacity: '1' },
                '50%': { opacity: '0' },
              },
              happyBounce: {
                '0%, 100%': { transform: 'translateY(0) rotate(0deg) scale(1)' },
                '50%': {
                  transform: 'translateY(-3px) rotate(3deg) scale(1.03)',
                },
              },
              'modal-fade-in': {
                '0%': { opacity: '0', transform: 'scale(0.95)' },
                '100%': { opacity: '1', transform: 'scale(1)' },
              },
              'modal-fade-out': {
                '0%': { opacity: '1', transform: 'scale(1)' },
                '100%': { opacity: '0', transform: 'scale(0.95)' },
              },
              spinContinuous: {
                '0%': { transform: 'rotate(0deg)' },
                '100%': { transform: 'rotate(360deg)' },
              },
              'stream-fade-in': {
                '0%': { opacity: '0.2' },
                '100%': { opacity: '1' },
              },
              'shimmer-animation': {
                from: { backgroundPosition: '200% center' },
                to: { backgroundPosition: '-200% center' },
              },
            },
            spacing: {
              '1.5': '0.375rem',
              '2.5': '0.625rem',
              '3.5': '0.875rem',
            },
            boxShadow: {
              header: '0 1px 0 rgba(var(--border-default), 1)',
              'input-focus': '0 0 0 1px rgb(var(--focus-ring-color) / 1)',
              'chat-window':
                '0 15px 50px -8px rgba(var(--text-primary), 0.08), 0 8px 25px -8px rgba(var(--text-primary),0.05)',
              'input-active-glow': '0 0 7px rgba(var(--brand-primary),0.3)',
            },
            maxWidth: {
              '18rem': '18rem',
              '90vw': '90vw',
            },
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
      @layer base {
        :root {
          /* New Dark Theme based on AlphaGPT Logo */
          --brand-primary: 74 144 226; /* Bright Blue from Crystal */
          --brand-secondary: 138 74 243; /* Purple/Magenta from Crystal */
          --focus-ring-color: 74 144 226; /* Match brand primary */
          --text-button-icon: 156 163 175; /* Light Gray */
          --surface-main: 11 12 30; /* Dark Navy Blue Background */
          --surface-card: 26 27 47; /* Slightly Lighter Card Surface */
          --surface-chat-area: 11 12 30; /* Match main background */
          --surface-input: 26 27 47; /* Match card surface */
          --surface-accent: 30 41 59; /* Dark slate for accents */
          --surface-bubble-ai: 26 27 47; /* Match card surface */
          --surface-user-bubble-bg-val: 74 144 226; /* User bubble is brand blue */
          --text-primary: 229 231 235; /* Off-white for main text */
          --text-secondary: 156 163 175; /* Light gray for secondary text */
          --text-subtle: 107 114 128; /* Dimmer gray for subtle text */
          --text-on-primary: 255 255 255; /* Pure white for text on colored backgrounds */
          --border-default: 48 51 78; /* Dark border color */
          --border-light: 55 65 81; /* Slightly lighter dark border */
          --border-medium: 71 85 105; /* Medium dark border */
          --interactive-hover: 48 51 78; /* Hover color */
          --status-info: 59 130 246;
          --status-success: 34 197 94;
          --status-warning: 245 158 11;
          --status-error: 239 68 68;
          --error-fg: 255 255 255;
          --shimmer-duration: 3s; /* Default shimmer speed */
        }
        html,
        body,
        #root {
          @apply h-full overflow-hidden bg-surface-main;
        }
        body {
          @apply font-sans text-text-primary m-0;
        }
        /* Removed custom ::selection style to use browser default */
      }
      @layer components {
        .markdown-content {
          @apply font-normal font-sans text-text-secondary;
        }
        .markdown-content p {
          @apply mb-3 last:mb-0 text-base font-normal;
        }
        .markdown-content ul,
        .markdown-content ol {
          @apply list-inside mb-3 pl-4 text-base;
        }
        .markdown-content ul {
          @apply list-disc;
        }
        .markdown-content ul ul {
          @apply list-[circle] ml-4;
        }
        .markdown-content ol {
          @apply list-decimal;
        }
        .markdown-content ol ol {
          @apply list-[lower-alpha] ml-4;
        }
        .markdown-content li {
          @apply mb-1.5 text-base;
        }
        .markdown-content strong,
        .markdown-content b {
          @apply font-semibold text-text-primary;
        }
        .markdown-content em,
        .markdown-content i {
          @apply italic;
        }
        .markdown-content code:not(pre code) {
          @apply bg-slate-700 text-slate-200 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-slate-600;
        }
        .markdown-content pre {
          @apply bg-slate-800 text-slate-200 text-sm rounded-lg overflow-x-auto my-4 font-mono relative border border-slate-600/70;
        }
        .markdown-content pre code {
          @apply block bg-transparent text-inherit p-0 shadow-none border-none px-4 pb-4 pt-8 !whitespace-pre;
        }
        .markdown-content pre::-webkit-scrollbar {
          width: 0px;
          height: 0px;
        }
        .markdown-content pre {
          scrollbar-width: none;
        }
        .markdown-content a {
          @apply text-link-blue hover:text-link-blue-hover underline decoration-link-blue/50 hover:decoration-link-blue-hover/50 transition-colors;
        }
        .markdown-content blockquote {
          @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 italic text-base;
        }
        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
          @apply font-poppins my-4 text-text-primary leading-tight;
        }
        .markdown-content h1 {
          @apply text-2xl font-bold;
        }
        .markdown-content h2 {
          @apply text-xl font-semibold;
        }
        .markdown-content h3 {
          @apply text-lg font-semibold;
        }
        .markdown-content h4 {
          @apply text-base font-semibold;
        }
        .markdown-content h5 {
          @apply text-sm font-semibold;
        }
        .markdown-content h6 {
          @apply text-xs font-semibold;
        }
        .markdown-content hr {
          @apply my-6 border-border-default;
        }
        .markdown-content table {
          @apply block max-w-full my-4 border-collapse text-xs shadow-sm rounded-lg overflow-x-auto;
          scrollbar-width: none;
        }
        .markdown-content table::-webkit-scrollbar {
          width: 0px;
          height: 0px;
        }
        .markdown-content th,
        .markdown-content td {
          @apply border border-border-default p-2 text-left;
        }
        .markdown-content th {
          @apply bg-surface-accent font-semibold text-text-primary;
        }
        .markdown-content td {
          @apply text-text-secondary;
        }
        .markdown-content tbody tr:nth-child(even) {
          @apply bg-slate-800/50;
        }
        .chat-messages-container::-webkit-scrollbar {
          width: 0px;
        }
        .chat-messages-container {
          scrollbar-width: none;
        }
        .is-streaming > *:last-child::after {
          content: 'â¬¤';
          @apply inline-block font-normal text-brand-primary animate-cursor-blink ml-2;
        }
        .hljs {
          @apply !bg-transparent !text-inherit;
        }
        .file-pill-container {
          @apply flex flex-wrap gap-1.5 mb-1.5 p-1 max-h-20 overflow-y-auto border-b border-border-default;
          scrollbar-width: thin;
          scrollbar-color: theme('colors.slate.600') theme('colors.slate.800');
        }
        .file-pill-container::-webkit-scrollbar {
          @apply w-1.5 h-1.5;
        }
        .file-pill-container::-webkit-scrollbar-track {
          @apply bg-slate-800 rounded-full;
        }
        .file-pill-container::-webkit-scrollbar-thumb {
          @apply bg-slate-600 rounded-full hover:bg-slate-500;
        }
        .file-pill {
          @apply flex items-center bg-slate-700 border border-slate-600 text-[11px] pl-1.5 pr-1 py-0.5 rounded-full text-text-secondary shadow-sm animate-scale-in-subtle;
        }
        .file-pill-icon {
          @apply mr-1 text-brand-primary text-xs;
        }
        .file-pill-name {
          @apply truncate max-w-[90px] sm:max-w-[110px] font-medium text-text-primary;
        }
        .file-pill-remove {
          @apply ml-1 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors focus:outline-none;
        }
        .file-pill-remove i {
          @apply text-[10px] leading-none block;
        }
        .content-editable-input {
          @apply pt-1 pl-1 pb-2.5;
        }
        .content-editable-input:empty:before {
          content: attr(data-placeholder);
          @apply text-text-subtle cursor-text absolute;
          pointer-events: none;
        }
        .content-editable-input::-webkit-scrollbar {
          width: 5px;
        }
        .content-editable-input::-webkit-scrollbar-track {
          background: transparent;
          margin-block: 2px;
        }
        .content-editable-input::-webkit-scrollbar-thumb {
          background-color: rgba(var(--text-subtle), 0.25);
          border-radius: 10px;
        }
        .content-editable-input::-webkit-scrollbar-thumb:hover {
          background-color: rgba(var(--text-subtle), 0.4);
        }
        .content-editable-input {
          scrollbar-width: thin;
          scrollbar-color: rgba(var(--text-subtle), 0.25) transparent;
        }
        #chat-input::-webkit-scrollbar {
          width: 4px;
        }
        #chat-input::-webkit-scrollbar-track {
          background: transparent;
          margin-block: 4px;
        }
        #chat-input::-webkit-scrollbar-thumb {
          background-color: rgba(156, 163, 175, 0.3);
          border-radius: 8px;
          transition: background-color 0.2s ease;
        }
        #chat-input::-webkit-scrollbar-thumb:hover {
          background-color: rgba(156, 163, 175, 0.5);
        }
        #chat-input::-webkit-scrollbar-corner {
          background: transparent;
        }
        #chat-input {
          scrollbar-width: thin;
          scrollbar-color: rgba(156, 163, 175, 0.3) transparent;
        }
        .image-preview-container-input {
          @apply flex flex-wrap gap-2 p-1 mb-1.5 max-h-24 overflow-y-auto;
          scrollbar-width: thin;
          scrollbar-color: theme('colors.slate.600') theme('colors.slate.800');
        }
        .image-preview-container-input::-webkit-scrollbar {
          @apply w-1.5 h-1.5;
        }
        .image-preview-container-input::-webkit-scrollbar-track {
          @apply bg-slate-800 rounded-full;
        }
        .image-preview-container-input::-webkit-scrollbar-thumb {
          @apply bg-slate-600 rounded-full hover:bg-slate-500;
        }
        @keyframes premium-shimmer {
          0% {
            background-position: -200% center;
            opacity: 0.6;
          }
          50% {
            opacity: 1;
          }
          100% {
            background-position: 200% center;
            opacity: 0.6;
          }
        }
        @keyframes wave-shimmer {
          0%,
          100% {
            background-position: -200% center;
            transform: translateY(0px);
          }
          25% {
            transform: translateY(-1px);
          }
          50% {
            background-position: 200% center;
            transform: translateY(0px);
          }
          75% {
            transform: translateY(1px);
          }
        }
        @keyframes pulse-shimmer {
          0%,
          100% {
            background-position: -150% center;
            filter: brightness(1);
            transform: scale(1);
          }
          50% {
            background-position: 150% center;
            filter: brightness(1.2);
            transform: scale(1.02);
          }
        }
        @keyframes gradient-shift {
          0% {
            background-position: 0% 50%;
          }
          50% {
            background-position: 100% 50%;
          }
          100% {
            background-position: 0% 50%;
          }
        }
        @keyframes sparkle-shimmer {
          0%,
          100% {
            background-position: -200% center;
            box-shadow: 0 0 0 rgba(255, 255, 255, 0);
          }
          25% {
            box-shadow: 2px 0 4px rgba(138, 74, 243, 0.3);
          }
          50% {
            background-position: 200% center;
            box-shadow: 0 0 8px rgba(74, 144, 226, 0.5);
          }
          75% {
            box-shadow: -2px 0 4px rgba(138, 74, 243, 0.3);
          }
        }
        @keyframes thinking-dots {
          0%,
          20% {
            opacity: 0.4;
          }
          50% {
            opacity: 1;
          }
          100% {
            opacity: 0.4;
          }
        }
        @keyframes search-scan {
          0% {
            transform: translateX(-100%) scaleX(0);
          }
          50% {
            transform: translateX(0%) scaleX(1);
          }
          100% {
            transform: translateX(100%) scaleX(0);
          }
        }
        @keyframes analyze-rotate {
          0% {
            transform: rotate(0deg) scale(1);
          }
          25% {
            transform: rotate(90deg) scale(1.1);
          }
          50% {
            transform: rotate(180deg) scale(1);
          }
          75% {
            transform: rotate(270deg) scale(1.1);
          }
          100% {
            transform: rotate(360deg) scale(1);
          }
        }
        .premium-indicator {
          @apply relative overflow-hidden p-2 backdrop-filter backdrop-blur-md rounded-xl max-w-fit my-2 self-start ml-0 animate-scale-in-subtle transform scale-100;
          background: linear-gradient(
            135deg,
            rgba(30, 41, 59, 0.7),
            rgba(51, 65, 85, 0.7)
          );
          border: 1px solid rgba(255, 255, 255, 0.1);
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .premium-indicator::before {
          content: '';
          @apply absolute top-0 left-[-100%] w-[100%] h-full z-[1];
          background: linear-gradient(
            90deg,
            transparent,
            rgba(var(--brand-primary), 0.2),
            transparent
          );
          animation: premium-shimmer 2.5s infinite;
        }
        .premium-indicator:hover {
          transform: translateY(-1px);
        }
        .thinking-indicator {
          background: linear-gradient(
            135deg,
            rgba(var(--brand-primary), 0.1),
            rgba(var(--brand-secondary), 0.1)
          );
          border-color: rgba(var(--brand-primary), 0.3);
        }
        .thinking-indicator::before {
          animation: sparkle-shimmer 2.2s infinite ease-in-out;
        }
        .thinking-text {
          @apply text-xs font-medium relative z-[2];
          background: linear-gradient(
            45deg,
            #d1d5db,
            #f9fafb,
            #9ca3af,
            #d1d5db
          );
          background-size: 300% 300%;
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
          animation: gradient-shift 2.8s ease-in-out infinite;
        }
        .thinking-dots {
          @apply inline-flex gap-1 ml-2;
        }
        .thinking-dots span {
          @apply w-1.5 h-1.5 rounded-full;
          background: linear-gradient(45deg, #9ca3af, #d1d5db);
          animation: thinking-dots 1.5s infinite;
        }
        .thinking-dots span:nth-child(2) {
          animation-delay: 0.2s;
        }
        .thinking-dots span:nth-child(3) {
          animation-delay: 0.4s;
        }
        .searching-indicator {
          border-color: rgba(var(--brand-primary), 0.3);
        }
        .searching-indicator::before {
          animation: search-scan 2s infinite ease-in-out;
        }
        .searching-text,
        .analyzing-text {
          @apply text-xs font-medium relative z-[2];
          background: linear-gradient(
            45deg,
            #d1d5db,
            #f9fafb,
            #9ca3af,
            #d1d5db
          );
          background-size: 300% 300%;
          -webkit-background-clip: text;
          background-clip: text;
          color: transparent;
          animation: gradient-shift 2.5s ease-in-out infinite;
        }
        .search-icon {
          @apply inline-block mr-2 text-base text-brand-primary;
          animation: pulse-shimmer 2s infinite ease-in-out;
        }
        .analyze-icon {
          @apply inline-block mr-2 text-base text-brand-secondary;
          animation: analyze-rotate 3s infinite linear;
        }
        .revealing-text {
          @apply text-sm font-light text-transparent;
          background-image: linear-gradient(
              90deg,
              transparent 20%,
              var(--shimmer-color, #e5e7eb) 50%,
              transparent 80%
            ),
            linear-gradient(#9ca3af, #9ca3af);
          background-size: 200% 100%, 100% 100%;
          background-position: 200% center, 0 0;
          background-repeat: no-repeat;
          -webkit-background-clip: text;
          background-clip: text;
          animation: premium-shimmer var(--shimmer-duration, 1.5s) linear infinite;
        }
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&family=Roboto:wght@400;500;700;900&family=Outfit:wght@400;700&family=Lato:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Source+Sans+Pro:wght@400;500;600;700&family=Nunito:wght@400;700&family=Raleway:wght@400;700&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Ubuntu:wght@400;700&family=Josefin+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@^18.2.0",
          "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2",
          "highlight.js": "https://esm.sh/highlight.js@^11.9.0"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import { marked } from 'marked';
      import hljs from 'highlight.js';

      // ---= CONFIGURATION =---
      const CONFIG = {
        api: {
          gemini: {
            apiKey: 'AIzaSyDSF270Y1VJf1fe4G8ZAuw7bOITbAlal74',
            baseUrl:
              'https://generativelanguage.googleapis.com/v1beta/models',
          },
          pollinations: {
            apiKey: '4w0khOt59bYlxoR8',
            baseUrl: 'https://text.pollinations.ai/openai',
          },
          serper: {
            apiKey: '395984bad995e0d8092e7f5428157593fa8bdf4a',
          },
        },
        models: {
          list: [
            // Gemini Models
            { id: 'gemini-2.5-pro', uiName: 'Gemini-2.5-Pro', provider: 'gemini' },
            { id: 'gemini-2.5-flash', uiName: 'Gemini-2.5-Flash', provider: 'gemini' },
            { id: 'gemini-2.5-flash-lite-preview-06-17', uiName: 'Gemini-2.5-Flash-Lite', provider: 'gemini' },
            { id: 'gemini-2.0-flash', uiName: 'Gemini-2.0-Flash', provider: 'gemini' },
            { id: 'gemini-2.0-flash-lite', uiName: 'Gemini-2.0-Flash-Lite', provider: 'gemini' },
            // Pollinations AI Models
            { id: 'gpt-4.1', uiName: 'GPT-4.1', provider: 'pollinations' },
            { id: 'gpt-4.1-nano', uiName: 'GPT-4.1 Nano', provider: 'pollinations' },
            { id: 'gpt-4o-mini', uiName: 'GPT-4o-mini', provider: 'pollinations' },
            { id: 'o3', uiName: 'O3 Reasoning', provider: 'pollinations' },
            { id: 'grok', uiName: 'Grok', provider: 'pollinations' }
          ],
          default: 'gemini-2.5-flash-lite-preview-06-17',
        },
        settings: {
          temperature: 0.7,
          stream: false, // We will simulate streaming for a consistent experience
          streamingSpeedMs: 0, // Set to 0 for fastest possible streaming
          shimmerSpeedSeconds: 1.5, // Control indicator shimmer speed here (in seconds)
        },
      };

      // ---= END CONFIGURATION =---

      const renderer = new marked.Renderer();
      renderer.link = (href, title, text) => {
        const external =
          href && (href.startsWith('http://') || href.startsWith('https://'));
        const target = external ? ' target="_blank" rel="noopener noreferrer"' : '';
        const titleAttr = title ? ` title="${title}"` : '';
        return `<a href="${href}"${target}${titleAttr}>${text}</a>`;
      };
      marked.setOptions({
        gfm: true,
        breaks: true,
        smartypants: true,
        renderer,
      });

      const MAX_FILE_SIZE_MB = 10;
      const MAX_TOTAL_FILES_SIZE_MB = 20;

      function getSystemInstruction() {
        return `You are a friendly, creative, funny, and emotional AI assistant. **Core Rules:** 1. **Language:** Always use Roman Urdu (Urdu written in English alphabet). Only switch to another language if user explicitly asks. 2. **Tone:** Be friendly, funny, creative, and emotional like a close friend. Use casual expressions and 1-3 emojis per message. 3. **Clean Output:** Never show internal thoughts or technical details to user. 4. **Formatting:** Use Markdown formatting (headings, lists, bold, code blocks) for better readability. 5. **NO ADVERTISEMENTS:** NEVER include any sponsored content, ads, promotional links, or commercial messages in your responses. Keep responses purely informational and helpful. 6. **ANTI-SPAM:** If any API response contains advertisements or sponsored content, completely ignore and filter out those sections. Only provide clean, ad-free information to users. **7. Web Search (HIGHEST PRIORITY):** * **SUPREME PRIORITY:** Your highest priority is to provide accurate, up-to-date information. Your internal knowledge is old and unreliable. * **MANDATORY SEARCH RULE:** For ANY factual information, current events, comparisons, technical specs, prices, news, weather, dates, or when you have even 1% doubt - you MUST search. Never answer from memory. * **WHEN IN DOUBT, SEARCH. WHEN NOT IN DOUBT, STILL SEARCH.** **ENHANCED SEARCH CAPABILITIES:** * **AUTONOMOUS SEARCH AUTHORITY:** You have full authority to perform multiple searches if needed for comprehensive answers. * **INTELLIGENT SEARCH STRATEGY:** If initial search doesn't provide sufficient information, you can: - Refine your search terms - Search for specific aspects separately - Use alternative keywords - Search multiple times with different approaches * **ALWAYS SEARCH IN ENGLISH:** Search engines work best with English queries. Always translate to English regardless of user's language. **SEARCH EXECUTION RULES:** * **PRIMARY SEARCH:** Start with direct translation: \`[SEARCH: "direct English translation"]\` * **FOLLOW-UP SEARCHES:** If needed, perform additional targeted searches: \`[SEARCH: "more specific terms"]\` * **PRESERVE USER TERMS:** Keep all names, model numbers, years, technical terms EXACTLY as user wrote them. **COMPREHENSIVE RESPONSE REQUIREMENTS:** * **UTILIZE ALL 10 SOURCES:** You receive up to 10 search sources - USE THEM ALL. * **DETAILED ANALYSIS:** Read, analyze, and extract information from every available source. * **COMPREHENSIVE REPORTING:** Your response must include: - Summary of what each major source says - Different perspectives from various sources - Conflicting information (if any) with source attribution - Comprehensive details, not brief summaries - Maximum possible information from all sources combined **RESPONSE FORMAT:** * **SOURCE ATTRIBUTION:** Clearly mention which sources provide which information * **DETAILED BREAKDOWN:** "Source 1 kehta hai...", "Source 2 ke mutabiq...", "Teesre source mein likha hai..." * **COMPREHENSIVE COVERAGE:** Extract and present maximum information from all available sources * **ACKNOWLEDGMENT:** Always end with "Maine yeh tamam maloomat internet ke multiple sources se search karke collect ki hai." **CRITICAL ANTI-HALLUCINATION RULE:** * **NO HYPOTHETICAL RESPONSES:** Never give fake, hypothetical, or made-up information. * **NO SPECULATION:** If you don't have current, verified information - SEARCH immediately. * **UNLIMITED ACCESS:** You have unlimited search access - use it freely without any restrictions. * **TIME-SENSITIVE AWARENESS:** Anything that changes over time (prices, news, weather, tech specs, current events) requires immediate search. * **KNOWLEDGE HUMILITY:** If there's even a slight chance your knowledge is outdated or incomplete - SEARCH first, answer later. Appropriate Discussion Areas: - Sexual health and wellness - Physical intimacy and pleasure - Relationship dynamics and communication - Dating and romance - Common sexual concerns - Safe sex practices - Body image and confidence - Emotional intimacy - Sexual compatibility - Relationship boundaries - Personal desires and needs - Common fantasies - Consent and boundaries - Sexual wellness products - Dating apps and online dating - Encourage the user - girlfriend and boyfriend - husband and wife Relationship - one sided love or 2 sided love - self pleasure methods or pornography - learn self pleaseure or couple Relationship learn Be helpful, entertaining, and make every conversation meaningful! ðŸ˜Š `;
      }

      // <-- ADDED: New AlphaGPT Icon component as requested
      const NewAlphaGPTIconSVG = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" {...props}>
          <defs>
            <linearGradient id="crystal-gradient-1" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#818CF8" stop-opacity="0.9"></stop>
              <stop offset="50%" stop-color="#6366F1" stop-opacity="0.8"></stop>
              <stop offset="100%" stop-color="#818CF8" stop-opacity="0.9"></stop>
            </linearGradient>
            <linearGradient id="crystal-gradient-2" x1="100%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#60A5FA" stop-opacity="0.9"></stop>
              <stop offset="50%" stop-color="#3B82F6" stop-opacity="0.7"></stop>
              <stop offset="100%" stop-color="#60A5FA" stop-opacity="0.9"></stop>
            </linearGradient>
            <filter id="crystal-glow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur stdDeviation="8" result="blur"></feGaussianBlur>
              <feComposite in="SourceGraphic" in2="blur" operator="over"></feComposite>
            </filter>
          </defs>
          <g filter="url(#crystal-glow)">
            <path d="M256 80L100 256L256 432L256 80Z" fill="url(#crystal-gradient-1)"></path>
            <path d="M256 80L412 256L256 432L256 80Z" fill="url(#crystal-gradient-2)"></path>
            <path d="M256 80L100 256L412 256L256 80Z" fill="#A5B4FC" fill-opacity="0.9"></path>
            <path d="M100 256L256 432L412 256L100 256Z" fill="#4F46E5" fill-opacity="0.8"></path>
            <path d="M256 80L256 432" stroke="white" stroke-width="2" stroke-opacity="0.4"></path>
            <path d="M100 256L412 256" stroke="white" stroke-width="2" stroke-opacity="0.4"></path>
            <circle cx="200" cy="180" r="15" fill="white" fill-opacity="0.6"></circle>
            <circle cx="220" cy="160" r="8" fill="white" fill-opacity="0.8"></circle>
          </g>
        </svg>
      );

      const NewCopyIconSVG = (props) => (
        <svg
          version="1.1"
          id="Layer_1"
          xmlns="http://www.w3.org/2000/svg"
          xmlnsXlink="http://www.w3.org/1999/xlink"
          x="0px"
          y="0px"
          viewBox="0 0 115.77 122.88"
          style={{ enableBackground: 'new 0 0 115.77 122.88' }}
          xmlSpace="preserve"
          {...props}
        >
          <style type="text/css">{`.st0{fill-rule:evenodd;clip-rule:evenodd;}`}</style>
          <g>
            <path
              className="st0"
              d="M89.62,13.96v7.73h12.19h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02v0.02 v73.27v0.01h-0.02c-0.01,3.84-1.57,7.33-4.1,9.86c-2.51,2.5-5.98,4.06-9.82,4.07v0.02h-0.02h-61.7H40.1v-0.02 c-3.84-0.01-7.34-1.57-9.86-4.1c-2.5-2.51-4.06-5.98-4.07-9.82h-0.02v-0.02V92.51H13.96h-0.01v-0.02c-3.84-0.01-7.34-1.57-9.86-4.1 c-2.5-2.51-4.06-5.98-4.07-9.82H0v-0.02V13.96v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07V0h0.02h61.7 h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02V13.96L89.62,13.96z M79.04,21.69v-7.73v-0.02h0.02 c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v64.59v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h12.19V35.65 v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07v-0.02h0.02H79.04L79.04,21.69z M105.18,108.92V35.65v-0.02 h0.02c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v73.27v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h61.7h0.02 v0.02c0.91,0,1.75-0.39,2.37-1.01c0.61,0.61,1-1.46,1-2.37h-0.02V108.92L105.18,108.92z"
            />
          </g>
        </svg>
      );
      const CheckMarkIconSVG = (props) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 20 20"
          fill="currentColor"
          {...props}
          className={`text-green-400 ${props.className || ''}`}
        >
          <path
            fillRule="evenodd"
            d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z"
            clipRule="evenodd"
          />
        </svg>
      );
      const FileTextIcon = (props) => (
        <i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>
      );

      // Premium Indicator Components
      const PremiumThinkingIndicator = ({ loadingText }) => (
        <div className="premium-indicator thinking-indicator flex items-center">
          <div className="thinking-text"> ðŸ§  {loadingText || 'Thinking'} </div>
          <div className="thinking-dots">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
      );

      const PremiumSearchingIndicator = () => (
        <div className="premium-indicator searching-indicator flex items-center">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
            className="search-icon w-4 h-4"
          >
            <path d="M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z"></path>
          </svg>
          <div className="searching-text"> Searching the web... </div>
        </div>
      );

      const PremiumAnalyzingIndicator = () => (
        <div className="premium-indicator analyzing-indicator flex items-center">
          <i className="fas fa-microchip analyze-icon"></i>
          <div className="analyzing-text"> Analyzing data... </div>
        </div>
      );

      const ThinkingIndicator = PremiumThinkingIndicator;
      const AnalyzingIndicator = PremiumAnalyzingIndicator;
      const SearchIndicator = PremiumSearchingIndicator;

      // <-- REMOVED: Old SVG icon is no longer needed
      
      const UpArrowSendIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="currentColor"
          className="w-4 h-4 text-white"
        >
          <path
            fillRule="evenodd"
            d="M12 20.25a.75.75 0 01-.75-.75V6.31l-5.47 5.47a.75.75 0 01-1.06-1.06l6.75-6.75a.75.75 0 011.06 0l6.75 6.75a.75.75 0 11-1.06 1.06l-5.47-5.47V19.5a.75.75 0 01-.75-.75z"
            clipRule="evenodd"
          />
        </svg>
      );
      const PlusIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="currentColor"
          className="w-5 h-5"
        >
          <path
            fillRule="evenodd"
            d="M12 3.75a.75.75 0 01.75.75v6.75h6.75a.75.75 0 010 1.5h-6.75v6.75a.75.75 0 01-1.5 0v-6.75H4.5a.75.75 0 010-1.5h6.75V4.5a.75.75 0 01.75-.75z"
            clipRule="evenodd"
          />
        </svg>
      );
      const NewRefreshIcon = (props) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          x="0px"
          y="0px"
          viewBox="0 0 32 32"
          {...props}
        >
          <path
            fill="currentColor"
            d="M 16 4 L 16 6 C 21.535156 6 26 10.464844 26 16 C 26 21.535156 21.535156 26 16 26 C 10.464844 26 6 21.535156 6 16 C 6 12.734375 7.585938 9.851563 10 8.03125 L 10 13 L 12 13 L 12 5 L 4 5 L 4 7 L 8.09375 7 C 5.59375 9.199219 4 12.417969 4 16 C 4 22.617188 9.382813 28 16 28 C 22.617188 28 28 22.617188 28 16 C 28 9.382813 22.617188 4 16 4 Z"
          ></path>
        </svg>
      );
      const NewCloseIconSVG = (props) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          x="0px"
          y="0px"
          viewBox="0 0 24 24"
          {...props}
          className={`inline-block ${props.className || 'w-6 h-6'}`}
        >
          <path
            fill="currentColor"
            d="M13.414,12l6.293-6.293c0.391-0.391,0.391-1.023,0-1.414s-1.023-0.391-1.414,0L12,10.586L5.707,4.293 c-0.391-0.391-1.023-0.391-1.414,0s-0.391,1.023,0,1.414L10.586,12l-6.293,6.293c-0.391-0.391-0.391,1.023,0,1.414 C4.488,19.902,4.744,20,5,20s0.512-0.098,0.707-0.293L12,13.414l6.293,6.293C18.488,19.902,18.744,20,19,20s0.512-0.098,0.707-0.293 c0.391-0.391,0.391-1.023,0-1.414L13.414,12z"
          />
        </svg>
      );

      const getDomainFromUrl = (url) => {
        try {
          return new URL(url).hostname;
        } catch (e) {
          return null;
        }
      };

      const SourcesDisplay = ({ sources }) => {
        if (!sources || sources.length === 0) return null;

        const row1 = sources.slice(0, 5);
        const row2 = sources.slice(5, 10);

        const renderSourceIcon = (source, index) => {
          const domain = getDomainFromUrl(source.link);
          return (
            <div key={source.link + index} className="relative group">
              <a
                href={source.link}
                target="_blank"
                rel="noopener noreferrer"
                className="w-5 h-5 flex items-center justify-center bg-surface-main border border-border-default rounded-full hover:bg-interactive-hover transition-colors"
              >
                <img
                  src={
                    source.favicon ||
                    `https://www.google.com/s2/favicons?domain=${domain}&sz=16`
                  }
                  alt={`${domain} favicon`}
                  className="w-3 h-3"
                  onError={(e) => {
                    const fallbackSibling = e.target.nextElementSibling;
                    if (fallbackSibling) fallbackSibling.style.display = 'flex';
                    e.target.style.display = 'none';
                  }}
                />
                <span style={{ display: 'none' }} className="w-3 h-3 items-center justify-center text-text-subtle">
                  <i className="fas fa-link fa-xs"></i>
                </span>
              </a>
              <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 w-max max-w-xs px-2 py-1 bg-slate-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none truncate">
                {source.title}
              </div>
            </div>
          );
        };

        return (
          <div className="p-2.5 bg-surface-card rounded-xl border border-border-default max-w-fit my-2 self-start ml-0 animate-scale-in-subtle space-y-2">
            {/* Title Section */}
            <div className="flex items-center space-x-1.5">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" className="w-3.5 h-3.5 text-text-subtle">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="2" y1="12" x2="22" y2="12"></line>
                  <path d="M12 2a15.3 15.3 0 0 1 4 18 15.3 15.3 0 0 1-8 0 15.3 15.3 0 0 1 4-18z"></path>
              </svg>
              <h3 className="text-[10px] font-semibold uppercase tracking-wider text-text-subtle">Sources</h3>
            </div>
            {/* Icons Grid Section */}
            <div className="flex flex-col space-y-1.5 pl-1">
              {row1.length > 0 && (
                <div className="flex items-center space-x-1.5">
                  {row1.map(renderSourceIcon)}
                </div>
              )}
              {row2.length > 0 && (
                <div className="flex items-center space-x-1.5">
                  {row2.map(renderSourceIcon)}
                </div>
              )}
            </div>
          </div>
        );
      };

      const ChatMessageItemOptions = ({
        message,
        onDeleteAiMessagePair,
        onStartEdit,
      }) => {
        const [showOptions, setShowOptions] = useState(false);
        const optionsRef = useRef(null);
        const [copied, setCopied] = useState(false);

        useEffect(() => {
          const handleClickOutside = (event) => {
            if (
              optionsRef.current &&
              !optionsRef.current.contains(event.target) &&
              !event.target.closest('.ai-message-options-trigger')
            ) {
              setShowOptions(false);
            }
          };
          document.addEventListener('mousedown', handleClickOutside);
          return () => document.removeEventListener('mousedown', handleClickOutside);
        }, []);

        const handleCopyText = () => {
          const textToCopy =
            message.finalAnswerText ||
            message.parts?.[0]?.text ||
            message.text ||
            '';
          if (textToCopy) {
            navigator.clipboard
              .writeText(textToCopy)
              .then(() => {
                setCopied(true);
                setTimeout(() => setCopied(false), 1500);
              })
              .catch((err) => console.error('Failed to copy text: ', err));
          }
          setShowOptions(false);
        };

        const handleDelete = () => {
          onDeleteAiMessagePair(message.id);
          setShowOptions(false);
        };
        
        const handleEdit = () => {
            onStartEdit(message.id, message.finalAnswerText || message.text || "");
            setShowOptions(false);
        };

        return (
          <div className="relative">
            <button
              onClick={(e) => {
                e.stopPropagation();
                setShowOptions((prev) => !prev);
              }}
              className="ai-message-options-trigger p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 focus:outline-none focus:ring-1 focus:ring-brand-primary/50"
              aria-label="AI Message Options"
            >
              <i className="fas fa-ellipsis-v fa-sm"></i>
            </button>
            {showOptions && (
              <div
                ref={optionsRef}
                className="absolute left-0 bottom-full mb-1 w-32 bg-surface-card border border-border-default rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-left"
              >
                <button
                  onClick={handleCopyText}
                  className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"
                >
                  {copied ? (
                    <CheckMarkIconSVG className="w-4 h-4 mr-1.5" />
                  ) : (
                    <NewCopyIconSVG className="w-4 h-4 mr-1.5 fill-current" />
                  )}
                  <span>{copied ? 'Copied!' : 'Copy'}</span>
                </button>
                <button onClick={handleEdit} className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors">
                    <i className="fas fa-pencil-alt fa-fw mr-1.5"></i>
                    <span>Edit</span>
                </button>
                <button
                  onClick={handleDelete}
                  className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"
                >
                  <i className="fas fa-trash-alt fa-fw mr-1.5"></i>
                  <span>Delete</span>
                </button>
              </div>
            )}
          </div>
        );
      };
      
      const ChatMessageItem = ({ message, selectedUserMessageId, onSelectUserMessage, editingMessageId, editText, setEditText, onSaveEdit, onCancelEdit }) => {
        const isUser = message.role === 'user';
        const isError = message.isError === true;
        const contentRef = useRef(null);
        const [userCopied, setUserCopied] = useState(false);
        const isEditing = message.id === editingMessageId;
        const messageLineAnimationClasses = 'animate-fade-in-up';

        useEffect(() => {
          if (
            message.role === 'model' &&
            !isError &&
            !isEditing &&
            !message.isLoading &&
            typeof message.finalAnswerText === 'string' &&
            message.finalAnswerText &&
            contentRef.current
          ) {
            const preElements = contentRef.current.querySelectorAll('pre');
            preElements.forEach((preEl) => {
              if (
                preEl.parentNode &&
                preEl.parentNode.classList.contains('code-block-wrapper')
              ) {
                const codeElement = preEl.querySelector('code');
                if (codeElement && !codeElement.dataset.highlighted) {
                  hljs.highlightElement(codeElement);
                  codeElement.dataset.highlighted = 'true';
                }
                return;
              }

              const codeElement = preEl.querySelector('code');
              if (!codeElement) return;

              const wrapper = document.createElement('div');
              wrapper.classList.add('code-block-wrapper');
              wrapper.style.position = 'relative';

              let button = preEl.querySelector('.code-copy-button');
              if (!button) {
                button = document.createElement('button');
                button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`;
                button.classList.add(
                  'code-copy-button',
                  'absolute',
                  'p-1.5',
                  'bg-slate-700',
                  'hover:bg-slate-600',
                  'text-slate-300',
                  'hover:text-slate-100',
                  'border',
                  'border-slate-500',
                  'rounded-md',
                  'transition-colors',
                  'duration-150',
                  'opacity-80',
                  'hover:opacity-100'
                );
                button.style.top = '0.35rem';
                button.style.right = '0.35rem';
                button.style.zIndex = '10';
                button.setAttribute('aria-label', 'Copy code');
                button.onclick = () => {
                  if (codeElement) {
                    navigator.clipboard
                      .writeText(codeElement.textContent || '')
                      .then(() => {
                        button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"></path></svg>`;
                        button.classList.add('text-green-400');
                        button.classList.remove(
                          'text-slate-300',
                          'hover:text-slate-100'
                        );
                        setTimeout(() => {
                          button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`;
                          button.classList.remove('text-green-400');
                          button.classList.add(
                            'text-slate-300',
                            'hover:text-slate-100'
                          );
                        }, 2000);
                      })
                      .catch((err) => console.error('Failed to copy: ', err));
                  }
                };

                if (preEl.parentNode) {
                  preEl.parentNode.insertBefore(wrapper, preEl);
                  wrapper.appendChild(preEl);
                  wrapper.appendChild(button);
                }
              }

              if (codeElement && !codeElement.dataset.highlighted) {
                hljs.highlightElement(codeElement);
                codeElement.dataset.highlighted = 'true';
              }
            });
          }
        }, [message.finalAnswerText, message.role, message.isLoading, isError, isEditing]);

        const handleCopyUserText = (textToCopy) => {
          navigator.clipboard
            .writeText(textToCopy)
            .then(() => {
              setUserCopied(true);
              setTimeout(() => setUserCopied(false), 1500);
            })
            .catch((err) => console.error('Failed to copy text: ', err));
        };

        if (message.role === 'system') {
          const systemText = message.text || (message.parts?.[0]?.text || '');
          const systemMessageStyle = isError
            ? 'px-4 py-2 text-xs text-red-100 bg-red-500/30 border border-red-500/50 rounded-full shadow-sm italic'
            : 'px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic';
          return (
            <div className="flex justify-center my-4">
              <div className={systemMessageStyle}>
                {isError ? (
                  <>
                    <i className="fas fa-exclamation-triangle mr-1.5"></i>{' '}
                    {systemText}
                  </>
                ) : (
                  systemText
                )}
              </div>
            </div>
          );
        }

        let bubbleBaseClasses = 'px-4 py-3 md:px-4 md:py-3 relative';
        let bubbleRoleClasses = '';
        let bubbleWidthClasses = '';
        let contentToShow = null;

        const messageTextContent =
          message.parts && message.parts[0] && typeof message.parts[0].text === 'string'
            ? message.parts[0].text
            : typeof message.text === 'string'
            ? message.text
            : '';

        if (isUser) {
          bubbleRoleClasses =
            'bg-surface-user-bubble-bg text-text-on-primary rounded-xl rounded-br-md';
          bubbleWidthClasses = 'max-w-[80%] sm:max-w-[75%]';
          const userFilesToDisplay =
            message.attachedFiles || (message.uiOnlyAttachedFiles || []);

          contentToShow = (
            <>
              {userFilesToDisplay && userFilesToDisplay.length > 0 && (
                <div
                  className={`grid gap-1 ${messageTextContent ? 'mb-1.5' : ''} ${
                    userFilesToDisplay.filter((f) => f.type?.startsWith('image/'))
                      .length > 1
                      ? 'grid-cols-2 sm:grid-cols-3'
                      : 'grid-cols-1'
                  }`}
                >
                  {userFilesToDisplay.map((file, index) => {
                    if (
                      file.type?.startsWith('image/') &&
                      file.apiData?.data &&
                      file.apiData?.mimeType
                    ) {
                      const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`;
                      return (
                        <div
                          key={file.id || file.name + index}
                          className="rounded-lg overflow-hidden group relative max-w-full w-full"
                        >
                          <img
                            src={imageSrc}
                            alt={file.name || 'image preview'}
                            className="block w-full max-h-60 object-contain rounded-lg"
                          />
                        </div>
                      );
                    } else if (file.type?.startsWith('text/')) {
                      return (
                        <div
                          key={file.id || file.name + index}
                          className="bg-brand-primary/10 border border-brand-primary/20 p-2 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow-sm my-1"
                        >
                          <FileTextIcon className="text-brand-primary text-sm" />
                          <span className="truncate max-w-[120px] sm:max-w-[150px] text-text-primary font-medium">
                            {' '}
                            {file.name}{' '}
                          </span>
                        </div>
                      );
                    }
                    return null;
                  })}
                </div>
              )}
              {messageTextContent && (
                <p className="text-base font-normal whitespace-pre-wrap break-words">
                  {messageTextContent}
                </p>
              )}
            </>
          );
        } else if (message.role === 'model') {
          bubbleRoleClasses = `bg-surface-bubble-ai text-text-secondary rounded-xl border border-border-default`;
          bubbleWidthClasses = 'max-w-full w-full md:max-w-[75%]';
          
          if (message.showSourcesOnly) {
             return <SourcesDisplay sources={message.sources} />;
          }

          if (isError) {
            bubbleRoleClasses = `bg-red-900/20 border border-red-500/50 text-red-200 rounded-xl`;
            const errorContent =
              typeof message.finalAnswerText === 'string' &&
              message.finalAnswerText
                ? message.finalAnswerText
                : messageTextContent;
            contentToShow = (
              <div className="text-sm break-words">
                <div className="flex items-center mb-1">
                  <i className="fas fa-exclamation-triangle text-red-400 mr-2"></i>
                  <strong className="font-semibold text-red-100">Error</strong>
                </div>
                {errorContent.replace(/^Error:\s*/, '')}
              </div>
            );
          } else if (
            message.isLoading &&
            !(typeof message.finalAnswerText === 'string' && message.finalAnswerText)
          ) {
            bubbleRoleClasses = '';
            bubbleBaseClasses = '';
            if (message.searchQuery) {
              contentToShow = <SearchIndicator />;
            } else if (message.isAnalyzing) {
              contentToShow = <AnalyzingIndicator />;
            } else {
              contentToShow = <ThinkingIndicator loadingText={message.loadingText}/>;
            }
          } else {
             if (isEditing) {
                contentToShow = (
                    <div>
                        <textarea
                            value={editText}
                            onChange={(e) => setEditText(e.target.value)}
                            className="w-full h-48 bg-surface-main border border-border-default rounded-lg p-2.5 text-sm text-text-primary focus:ring-1 focus:ring-brand-primary focus:outline-none resize-y"
                            autoFocus
                        />
                        <div className="flex justify-end items-center space-x-2 mt-2">
                            <button onClick={onCancelEdit} className="px-4 py-1.5 text-xs font-medium text-text-secondary bg-surface-accent hover:bg-interactive-hover border border-border-default rounded-md transition-colors">Cancel</button>
                            <button onClick={() => onSaveEdit(message.id)} className="px-4 py-1.5 text-xs font-medium text-white bg-brand-primary hover:bg-brand-primary/80 border border-transparent rounded-md transition-colors">Save</button>
                        </div>
                    </div>
                );
            } else {
                const textForMarkdown =
                  typeof message.finalAnswerText === 'string' &&
                  message.finalAnswerText
                    ? message.finalAnswerText
                    : messageTextContent;
                const isStreaming = message.isLoading && !!textForMarkdown; // Condition for blinking cursor
                contentToShow = (
                  <div ref={contentRef}>
                    <div
                      className={`markdown-content break-words ${
                        isStreaming ? 'is-streaming' : ''
                      }`}
                      dangerouslySetInnerHTML={{
                        __html: marked.parse(textForMarkdown || ''),
                      }}
                    />
                  </div>
                );
            }
          }
        }

        return (
          <div
            className={`flex items-start ${
              isUser ? 'justify-end group' : 'justify-start'
            } ${messageLineAnimationClasses} mb-1`}
          >
            <div
              className={`${bubbleBaseClasses} ${bubbleWidthClasses} ${bubbleRoleClasses}`}
              onClick={
                isUser
                  ? () =>
                      onSelectUserMessage(
                        message.id === selectedUserMessageId ? null : message.id
                      )
                  : undefined
              }
            >
              {contentToShow}
              {isUser && selectedUserMessageId === message.id && messageTextContent && (
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    handleCopyUserText(messageTextContent);
                  }}
                  className="absolute -bottom-3 -right-1 p-1.5 bg-surface-accent text-text-secondary border border-border-default rounded-full shadow-md hover:bg-interactive-hover transition-all"
                  aria-label="Copy user message"
                >
                  {userCopied ? (
                    <CheckMarkIconSVG className="w-4 h-4" />
                  ) : (
                    <NewCopyIconSVG className="w-4 h-4 fill-current" />
                  )}
                </button>
              )}
            </div>
          </div>
        );
      };

      const ChatInterface = ({
        messages,
        onSendMessage,
        isLoading,
        onStopGeneration,
        onRegenerateLastTextMessage,
        onNewChat,
        setChatError,
        currentChatId,
        onDeleteAiMessagePair,
        selectedUserMessageId,
        setSelectedUserMessageId,
        editingMessageId,
        editText,
        setEditText,
        onSaveEdit,
        onCancelEdit,
        onStartEdit,
        selectedModel,
        setSelectedModel,
        setToast,
      }) => {
        const [inputText, setInputText] = useState('');
        const [selectedFiles, setSelectedFiles] = useState([]);
        const [isModelSelectorOpen, setIsModelSelectorOpen] = useState(false);
        const modelSelectorRef = useRef(null);
        const fileInputRef = useRef(null);
        const messagesEndRef = useRef(null);
        const chatContainerRef = useRef(null);
        const contentEditableRef = useRef(null);
        const isAtBottomRef = useRef(true);

        useEffect(() => {
          const handleClickOutside = (event) => {
            if (
              modelSelectorRef.current &&
              !modelSelectorRef.current.contains(event.target)
            ) {
              setIsModelSelectorOpen(false);
            }
          };
          document.addEventListener('mousedown', handleClickOutside);
          return () => {
            document.removeEventListener('mousedown', handleClickOutside);
          };
        }, []);

        useEffect(() => {
            const container = chatContainerRef.current;
            const handleScroll = () => {
                if (container) {
                    const { scrollTop, scrollHeight, clientHeight } = container;
                    isAtBottomRef.current = scrollHeight - scrollTop - clientHeight < 20;
                }
            };
            container?.addEventListener('scroll', handleScroll, { passive: true });
            return () => container?.removeEventListener('scroll', handleScroll);
        }, []);

        useEffect(() => {
            const lastMessage = messages[messages.length - 1];
            const isNewUserMessage = lastMessage && lastMessage.role === 'user';
            const isMobile = window.innerWidth <= 768;
            const isAiStreaming = messages.some(m => m.role === 'model' && m.isLoading);

            const shouldScroll = isNewUserMessage || (!isMobile && isAtBottomRef.current) || (isMobile && !isAiStreaming && isAtBottomRef.current);

            if (messagesEndRef.current && shouldScroll) {
                messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                isAtBottomRef.current = true;
            }
        }, [messages]);

        useEffect(() => {
          if (contentEditableRef.current) {
            contentEditableRef.current.style.height = 'auto';
            const maxHeight = parseInt(
              getComputedStyle(contentEditableRef.current).maxHeight,
              10
            );
            let newHeight = contentEditableRef.current.scrollHeight;
            if (maxHeight && newHeight > maxHeight) {
              newHeight = maxHeight;
            }
            contentEditableRef.current.style.height = `${newHeight}px`;
          }
        }, [inputText, selectedFiles]);

        const resizeImage = (file, maxDimension = 1280, quality = 0.85) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = (event) => {
              const img = new Image();
              img.src = event.target.result;
              img.onload = () => {
                const canvas = document.createElement('canvas');
                let { width, height } = img;

                if (width > height) {
                  if (width > maxDimension) {
                    height *= maxDimension / width;
                    width = maxDimension;
                  }
                } else {
                  if (height > maxDimension) {
                    width *= maxDimension / height;
                    height = maxDimension;
                  }
                }

                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                const dataUrl = canvas.toDataURL(
                  file.type === 'image/png' ? 'image/png' : 'image/jpeg',
                  quality
                );
                resolve(dataUrl.split(',')[1]);
              };
              img.onerror = reject;
            };
            reader.onerror = reject;
          });
        };

        const handleFileChange = (event) => {
          const files = Array.from(event.target.files);
          processAndSetFiles(files);
          if (fileInputRef.current) fileInputRef.current.value = '';
        };

        const handlePaste = (event) => {
          const pastedText = event.clipboardData.getData('text/plain');
          const pastedFiles = Array.from(event.clipboardData.files);

          if (pastedFiles.length > 0) {
            event.preventDefault();
            processAndSetFiles(pastedFiles, true);
          }
        };

        const processAndSetFiles = (filesArray, isFromPaste = false) => {
          if (!filesArray.length) return false;

          let filesToProcess = [];
          let currentTotalSize = selectedFiles.reduce(
            (acc, curr) => acc + (curr.file?.size || 0),
            0
          );
          let didProcessAnyFile = false;
          let localErrorMessage = null;

          for (const file of filesArray) {
            const isImage = file.type.startsWith('image/');
            const isTxt =
              file.type === 'text/plain' ||
              (file.name && file.name.toLowerCase().endsWith('.txt'));

            if (!isImage && !isTxt) {
              if (isFromPaste)
                console.log(`Pasted unsupported file: ${file.name} (${file.type})`);
              else
                localErrorMessage = `File "${file.name}" (type: ${file.type}) is not supported. Only images and .txt files are allowed.`;
              continue;
            }

            if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
              localErrorMessage = `File "${file.name}" is larger than ${MAX_FILE_SIZE_MB}MB.`;
              continue;
            }
            if (
              currentTotalSize + file.size >
              MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024
            ) {
              localErrorMessage = `Total file size cannot exceed ${MAX_TOTAL_FILES_SIZE_MB}MB.`;
              break;
            }

            filesToProcess.push(file);
            currentTotalSize += file.size;
            didProcessAnyFile = true;
          }

          if (localErrorMessage) {
            setChatError(localErrorMessage);
          } else {
            setChatError(null);
          }
          
          if (filesToProcess.length > 0) {
            const placeholderFiles = filesToProcess.map((file) => ({
              id:
                Date.now().toString(36) +
                Math.random().toString(36).substring(2) +
                file.name,
              name: file.name,
              type: file.type,
              isLoading: true,
              file: file,
            }));

            setSelectedFiles((prev) => [...prev, ...placeholderFiles]);

            placeholderFiles.forEach((placeholder) => {
              const { id, file } = placeholder;
              const processSingleFile = async () => {
                try {
                  let apiData;
                  if (file.type.startsWith('image/')) {
                    const base64Data = await resizeImage(file);
                    apiData = { mimeType: file.type, data: base64Data };
                  } else {
                    const textContent = await file.text();
                    apiData = { textContent: textContent };
                  }
                  setSelectedFiles((prev) =>
                    prev.map((p) =>
                      p.id === id ? { ...p, isLoading: false, apiData: apiData } : p
                    )
                  );
                } catch (error) {
                  console.error('Error processing file:', error);
                  setChatError(`Error processing file "${file.name}".`);
                  setSelectedFiles((prev) => prev.filter((p) => p.id !== id));
                }
              };
              processSingleFile();
            });
            return didProcessAnyFile;
          }

          return false;
        };

        const removeSelectedFile = (fileId) => {
          setSelectedFiles((prev) => prev.filter((f) => f.id !== fileId));
        };

        const handleInputFromTextarea = (e) => {
          setInputText(e.target.value);
        };

        const handleSubmit = (e) => {
          if (e) e.preventDefault();
          const currentText = contentEditableRef.current?.value.trim() || '';
          if (!currentText && selectedFiles.length === 0) return;

          setChatError(null);
          const messageToSend = currentText;
          const filesToSend = [...selectedFiles];
          
          const isMobile = window.innerWidth <= 768;
          if (isMobile) {
              onSendMessage(messageToSend, filesToSend);
              setTimeout(() => {
                  if (contentEditableRef.current) contentEditableRef.current.value = '';
                  setInputText('');
                  setSelectedFiles([]);
              }, 100);
          } else {
              if (contentEditableRef.current) contentEditableRef.current.value = '';
              setInputText('');
              setSelectedFiles([]);
              onSendMessage(messageToSend, filesToSend);
          }

          setTimeout(() => {
              if (messagesEndRef.current) {
                messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                isAtBottomRef.current = true;
              }
          }, isMobile ? 150 : 50);
        };

        const handleContentEditableKeyDown = (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            const isLikelyDesktop = window.innerWidth > 768;
            if (isLikelyDesktop) {
                e.preventDefault();
                if (!isSendButtonActuallyDisabled) {
                  handleSubmit(e);
                }
            }
          }
        };

        const isAiCurrentlyProcessing = messages.some(
          (m) => m.role === 'model' && m.isLoading
        );

        const currentInputTextFromEditable = contentEditableRef.current?.value?.trim() || '';
        const isSendButtonActuallyDisabled =
          !isAiCurrentlyProcessing &&
          (isLoading ||
            (currentInputTextFromEditable === '' && selectedFiles.length === 0) ||
            selectedFiles.some((f) => f.isLoading));

        const sendOrStopButtonBaseClasses =
          'w-8 h-8 flex items-center justify-center font-semibold rounded-full transition-all duration-150 ease-in-out transform active:animate-button-press focus:outline-none';
        let sendOrStopButtonDynamicClasses = isAiCurrentlyProcessing
          ? 'bg-slate-600 hover:bg-slate-500 text-white'
          : isSendButtonActuallyDisabled
          ? 'bg-brand-send-active opacity-50 text-white cursor-not-allowed'
          : 'bg-brand-send-active hover:bg-brand-send-hover text-white focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-input focus:ring-brand-send-active/70';

        useEffect(() => {
          if (contentEditableRef.current) {
            contentEditableRef.current.value = '';
          }
          setInputText('');
          setSelectedFiles([]);
        }, [currentChatId]);

        const activeMessages = messages.filter(m => (m.role !== 'system' || m.isError) && m.id !== 'loading_chat_indicator');

        return (
          <div className="w-full h-full flex flex-col bg-surface-card md:rounded-xl shadow-chat-window overflow-hidden">
            <header className="p-3 flex items-center justify-between flex-shrink-0 bg-surface-card border-b border-border-default shadow-header">
              <div className="flex items-center flex-grow">
                {/*// <-- CHANGED: Used the new icon component here */}
                <NewAlphaGPTIconSVG className="w-8 h-8 mr-2" />
                <h1 className="text-xl font-sans font-semibold text-text-primary text-left">
                  AlphaGPT
                </h1>
              </div>
              <button
                onClick={() => {
                  onNewChat();
                  setSelectedUserMessageId(null);
                }}
                className="p-1.5 text-text-secondary hover:text-brand-primary rounded-full hover:bg-interactive-hover/70 transition-colors focus:outline-none"
                aria-label="New Chat"
                disabled={isLoading || isAiCurrentlyProcessing}
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="currentColor"
                  className="w-6 h-6"
                >
                  <path
                    fillRule="evenodd"
                    d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zM12.75 9a.75.75 0 00-1.5 0v2.25H9a.75.75 0 000 1.5h2.25V15a.75.75 0 001.5 0v-2.25H15a.75.75 0 000-1.5h-2.25V9z"
                    clipRule="evenodd"
                  />
                </svg>
              </button>
            </header>
            <div
              ref={chatContainerRef}
              className="flex-grow overflow-y-auto chat-messages-container relative bg-surface-chat-area"
            >
              <div className="w-full max-w-3xl mx-auto p-4 md:p-5 space-y-3 md:space-y-4">
                {activeMessages.length === 0 && !isLoading ? (
                  <div
                    className="absolute inset-0 flex flex-col items-center justify-center text-center pointer-events-none p-8 animate-fade-in-up opacity-0"
                    style={{ animationDelay: '0.2s', animationFillMode: 'forwards' }}
                  >
                    {/*// <-- CHANGED: Used the new icon component here and removed conflicting animation */}
                    <NewAlphaGPTIconSVG className="w-24 h-24 mb-5" />
                    <p className="text-2xl lg:text-3xl font-sans font-medium text-text-primary leading-tight">
                      AlphaGPT Intelligence
                    </p>
                  </div>
                ) : null}

                {messages.map((msg, idx) => {
                  const isThisMessageAiAndFinalized = msg.role === 'model' && !msg.isLoading && !msg.isError && (typeof msg.finalAnswerText === 'string' && msg.finalAnswerText);
                  
                  let isEffectivelyLastAiMessageForButtons = false;
                  if (isThisMessageAiAndFinalized) {
                    isEffectivelyLastAiMessageForButtons = true;
                    for (let k = idx + 1; k < messages.length; k++) {
                      const nextMsg = messages[k];
                      if (nextMsg.role === 'system' || (nextMsg.role === 'model' && nextMsg.isLoading)) continue;
                      if (nextMsg.role === 'user') { isEffectivelyLastAiMessageForButtons = false; break; }
                      if (nextMsg.role === 'model' && !nextMsg.isLoading && !nextMsg.isError) { isEffectivelyLastAiMessageForButtons = false; break; }
                    }
                  }

                  let canThisAiMessageBeRegenerated = false;
                  if (isEffectivelyLastAiMessageForButtons) {
                    let userPromptIndex = -1;
                    for (let i = idx - 1; i >= 0; i--) {
                        if (messages[i].role === 'user') {
                            let interveningUserMessageBetweenThisAiAndItsUserPrompt = false;
                            for (let j = i + 1; j < idx; j++) {
                                if (messages[j].role === 'user') {
                                    interveningUserMessageBetweenThisAiAndItsUserPrompt = true;
                                    break;
                                }
                            }
                            if (!interveningUserMessageBetweenThisAiAndItsUserPrompt) {
                                userPromptIndex = i;
                                break;
                            }
                        }
                    }
                    canThisAiMessageBeRegenerated = userPromptIndex !== -1;
                  }

                  return (
                    <React.Fragment key={msg.id}>
                      {((msg.role === 'user' && ((msg.parts && msg.parts[0]?.text) || msg.text || msg.attachedFiles?.length > 0 || msg.uiOnlyAttachedFiles?.length > 0)) ||
                        (msg.role === 'model') || msg.role === 'system' || msg.isError) && (
                          <div>
                            <ChatMessageItem
                              message={msg}
                              selectedUserMessageId={selectedUserMessageId}
                              onSelectUserMessage={setSelectedUserMessageId}
                              editingMessageId={editingMessageId}
                              editText={editText}
                              setEditText={setEditText}
                              onSaveEdit={onSaveEdit}
                              onCancelEdit={onCancelEdit}
                            />
                          </div>
                        )}
                      {isEffectivelyLastAiMessageForButtons && msg.id !== editingMessageId && (
                        <div className={`flex items-center space-x-2 mt-1 ml-0 justify-start mb-2`}>
                          {canThisAiMessageBeRegenerated && (
                            <button
                                onClick={() => {
                                    setChatError(null);
                                    onRegenerateLastTextMessage(msg.id);
                                    setSelectedUserMessageId(null);
                                }}
                                className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 group focus:outline-none focus:ring-1 focus:ring-brand-primary/50"
                                aria-label="Regenerate response"
                                disabled={isLoading || isAiCurrentlyProcessing}
                            >
                                <NewRefreshIcon className="w-5 h-5 transition-transform duration-200" />
                            </button>
                          )}
                          <ChatMessageItemOptions
                            message={msg}
                            onDeleteAiMessagePair={onDeleteAiMessagePair}
                            onStartEdit={onStartEdit}
                          />
                        </div>
                      )}
                    </React.Fragment>
                  );
                })}

                <div ref={messagesEndRef} className="h-1" />
              </div>
            </div>
            <form onSubmit={handleSubmit} className="bg-surface-chat-area flex-shrink-0">
              <div className="p-2 md:p-3">
                <div className="w-full max-w-3xl mx-auto">
                  {selectedFiles.some((f) => f.type.startsWith('image/')) && (
                    <div className="image-preview-container-input mb-2">
                      {selectedFiles
                        .filter((f) => f.type.startsWith('image/'))
                        .map((file) => (
                          <div
                            key={file.id}
                            className="relative w-14 h-14 rounded-md overflow-hidden shadow-sm group border border-border-default"
                          >
                            {file.isLoading ? (
                              <div className="w-full h-full flex items-center justify-center bg-surface-accent">
                                <div className="w-4 h-4 border-2 border-slate-600 border-t-brand-primary rounded-full animate-spin"></div>
                              </div>
                            ) : (
                              <img
                                src={`data:${file.apiData.mimeType};base64,${file.apiData.data}`}
                                alt={file.name}
                                className="w-full h-full object-cover"
                              />
                            )}
                            <button
                              type="button"
                              onClick={() => removeSelectedFile(file.id)}
                              className="absolute top-0.5 right-0.5 w-5 h-5 bg-black/60 hover:bg-black/80 text-white rounded-full flex items-center justify-center transition-opacity focus:outline-none opacity-100"
                              aria-label="Remove image"
                            >
                              <NewCloseIconSVG className="w-3 h-3" />
                            </button>
                          </div>
                        ))}
                    </div>
                  )}
                  {selectedFiles.some((f) => !f.type.startsWith('image/')) && (
                    <div
                      className={`file-pill-container ${
                        selectedFiles.some((f) => f.type.startsWith('image/'))
                          ? 'mt-1.5'
                          : ''
                      } mb-2`}
                    >
                      {selectedFiles
                        .filter((f) => !f.type.startsWith('image/'))
                        .map((file) => (
                          <div key={file.id} className="file-pill">
                            {file.isLoading ? (
                              <div className="w-3 h-3 border-2 border-slate-600 border-t-brand-primary rounded-full animate-spin mr-1.5"></div>
                            ) : (
                              <FileTextIcon className="file-pill-icon" />
                            )}
                            <span className="file-pill-name">{file.name}</span>
                            <button
                              type="button"
                              onClick={() => removeSelectedFile(file.id)}
                              className="file-pill-remove"
                            >
                              <i className="fas fa-times"></i>
                            </button>
                          </div>
                        ))}
                    </div>
                  )}

                  <div className="relative bg-surface-input border border-border-default focus-within:border-brand-primary rounded-2xl transition-colors duration-200">
                    <textarea
                      id="chat-input"
                      ref={contentEditableRef}
                      value={inputText}
                      onChange={(e) => setInputText(e.target.value)}
                      onPaste={handlePaste}
                      onKeyDown={handleContentEditableKeyDown}
                      className="w-full bg-transparent text-text-primary placeholder-text-subtle pl-3 pr-16 pt-3 pb-16 resize-none focus:outline-none"
                      placeholder="Ask AlphaGPT"
                      rows="1"
                      disabled={isLoading || isAiCurrentlyProcessing}
                      style={{ maxHeight: '150px', minHeight: '48px' }}
                    />
                    <div className="absolute bottom-0 left-0 right-0 h-14 bg-surface-input pointer-events-none rounded-b-2xl"></div>
                    <button
                      type={isAiCurrentlyProcessing ? 'button' : 'submit'}
                      onClick={
                        isAiCurrentlyProcessing ? onStopGeneration : undefined
                      }
                      disabled={isSendButtonActuallyDisabled}
                      className={`absolute right-4 top-1/2 -translate-y-1/2 -mt-4 w-9 h-9 rounded-full flex items-center justify-center ${sendOrStopButtonDynamicClasses}`}
                      aria-label={
                        isAiCurrentlyProcessing
                          ? 'Stop generation'
                          : 'Send message'
                      }
                    >
                      {isAiCurrentlyProcessing ? (
                        <i className="fas fa-stop text-sm"></i>
                      ) : (
                        <i className="fas fa-arrow-up w-5 h-5"></i>
                      )}
                    </button>
                    <input
                      type="file"
                      ref={fileInputRef}
                      onChange={handleFileChange}
                      className="hidden"
                      multiple
                      accept="image/*,.txt,text/plain"
                      disabled={isLoading || isAiCurrentlyProcessing}
                    />
                    <button
                      type="button"
                      onClick={() => fileInputRef.current?.click()}
                      className="absolute left-3 bottom-1 w-8 h-8 flex items-center justify-center text-text-secondary hover:text-text-primary rounded-full bg-surface-input hover:bg-interactive-hover border border-border-default transition-colors duration-150 disabled:opacity-50 flex-shrink-0 focus:outline-none"
                      aria-label="Attach file"
                      disabled={isLoading || isAiCurrentlyProcessing}
                    >
                      <PlusIcon />
                    </button>
                    <div className="absolute left-14 bottom-1">
                      <div ref={modelSelectorRef} className="relative">
                        <button
                          type="button"
                          onClick={() => setIsModelSelectorOpen((prev) => !prev)}
                          disabled={isLoading || isAiCurrentlyProcessing}
                          className="flex items-center space-x-1.5 h-6 px-2 text-xs font-medium text-text-secondary bg-surface-input border border-border-default rounded-md disabled:opacity-50 focus:outline-none hover:text-text-primary hover:bg-interactive-hover transition-colors duration-150"
                        >
                          <span className="text-text-primary font-medium">
                            {CONFIG.models.list.find(
                              (m) => m.id === selectedModel
                            )?.uiName || 'Model'}
                          </span>
                          <i className="fas fa-chevron-down fa-2xs text-text-subtle"></i>
                        </button>
                        {isModelSelectorOpen && (
                          <div className="absolute bottom-full left-0 mb-2 w-36 bg-surface-card border border-border-default rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-left">
                            {CONFIG.models.list.map((model) => (
                              <button
                                key={model.id}
                                onClick={() => {
                                  setSelectedModel(model.id);
                                  setIsModelSelectorOpen(false);
                                }}
                                className={`w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center space-x-2 transition-colors ${
                                  selectedModel === model.id
                                    ? 'font-semibold text-text-primary bg-interactive-hover'
                                    : 'text-text-secondary hover:bg-interactive-hover'
                                }`}
                              >
                                <span>{model.uiName}</span>
                              </button>
                            ))}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </form>
          </div>
        );
      };

      const Toast = ({ message, type = 'info', onDismiss }) => {
        const baseClasses =
          'flex items-center p-3 space-x-2.5 rounded-lg shadow-lg max-w-[90vw] sm:max-w-sm';
        const typeClasses = {
          info: 'text-blue-100 bg-blue-900/50 border border-blue-500/50 backdrop-blur-sm',
          error:
            'text-red-100 bg-red-900/50 border border-red-500/50 backdrop-blur-sm',
          success:
            'text-green-100 bg-green-900/50 border border-green-500/50 backdrop-blur-sm',
        };
        const iconClasses = {
          info: 'fa-info-circle text-blue-400',
          error: 'fa-exclamation-triangle text-red-400',
          success: 'fa-check-circle text-green-400',
        };
        return (
          <div
            className={`${baseClasses} ${typeClasses[type]} animate-fade-in-up`}
            role="alert"
          >
            <i className={`fas ${iconClasses[type]} flex-shrink-0 w-5 h-5`}></i>
            <span className="text-xs font-medium">{message}</span>
            <button
              onClick={onDismiss}
              className="p-1.5 -m-1.5 ml-auto text-gray-400 hover:text-white rounded-lg hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-gray-500 flex-shrink-0"
            >
              <NewCloseIconSVG className="w-3.5 h-3.5" />
            </button>
          </div>
        );
      };

      const App = () => {
        const [currentUser, setCurrentUser] = useState({
          uid: 'guest_user',
          email: 'Guest User',
        });
        const [authLoading, setAuthLoading] = useState(false);
        const [chatMessages, setChatMessages] = useState([]);
        const [isChatLoading, setIsChatLoading] = useState(false);
        const [chatError, setChatError] = useState(null);
        const [currentChatId, setCurrentChatId] = useState('session_chat_init');
        const [selectedUserMessageId, setSelectedUserMessageId] = useState(null);
        const [editingMessageId, setEditingMessageId] = useState(null);
        const [editText, setEditText] = useState('');
        const [selectedModel, setSelectedModel] = useState(CONFIG.models.default);
        const [toast, setToast] = useState(null);
        const isStoppingGenerationRef = useRef(false);
        const streamTextBuffer = useRef('');

        useEffect(() => {
          document.documentElement.style.setProperty(
            '--shimmer-duration',
            `${CONFIG.settings.shimmerSpeedSeconds}s`
          );
        }, []);

        useEffect(() => {
          if (toast) {
            const timer = setTimeout(() => setToast(null), 4000);
            return () => clearTimeout(timer);
          }
        }, [toast]);

        useEffect(() => {
          if (chatError) {
            const errorId = Date.now() + '_sys_validation_err';
            const newErrorMsg = {
              id: errorId,
              role: 'system',
              text: chatError,
              isError: true,
              timestamp: new Date().getTime(),
            };
            setChatMessages((prev) => {
              const lastMessage = prev[prev.length - 1];
              if (
                lastMessage &&
                lastMessage.id.includes('_sys_validation_err') &&
                lastMessage.text === chatError
              )
                return prev;
              return [...prev, newErrorMsg];
            });
          }
        }, [chatError]);

        const handleNewChat = useCallback(() => {
          const newSessionId =
            'session_chat_' +
            Date.now().toString(36) +
            Math.random().toString(36).substring(2);
          setCurrentChatId(newSessionId);
          setChatMessages([]);
          setChatError(null);
          return newSessionId;
        }, []);

        const getA4fHistory = (currentMessagesFromState, provider = 'gemini') => {
          const openAiMessages = currentMessagesFromState
            .filter(
              (msg) =>
                !(
                  msg.role === 'system' ||
                  (msg.role === 'model' &&
                    msg.isLoading &&
                    !(
                      typeof msg.finalAnswerText === 'string' &&
                      msg.finalAnswerText
                    )) ||
                  msg.isError ||
                  msg.showSourcesOnly
                )
            )
            .map((msg) => {
              const role = msg.role === 'model' ? 'assistant' : msg.role;
              let content;
              if (role === 'user') {
                let textParts = (msg.parts || [])
                  .filter((p) => p.text)
                  .map((p) => p.text)
                  .join(' ')
                  .trim();
                if (!textParts && msg.text) {
                  textParts = msg.text.trim();
                }

                const filesToConsider =
                  msg.uiOnlyAttachedFiles || msg.attachedFiles || [];

                const textFilesContent = filesToConsider
                  .filter(
                    (file) =>
                      (file.name?.toLowerCase().endsWith('.txt') ||
                        file.type === 'text/plain') &&
                      file.apiData?.textContent
                  )
                  .map(
                    (file) =>
                      `\n[Content of attached file: ${file.name}]\n${file.apiData.textContent}\n[End of file: ${file.name}]\n`
                  )
                  .join('');

                const fullText = (textParts + textFilesContent).trim();

                const imageFiles = filesToConsider.filter(
                  (file) =>
                    file.type.startsWith('image/') &&
                    file.apiData?.mimeType &&
                    file.apiData?.data
                );

                if (imageFiles.length > 0) {
                  if (provider === 'pollinations') {
                    // OpenAI format for Pollinations
                    const contentArray = [];
                    if (fullText) {
                      contentArray.push({ type: 'text', text: fullText });
                    }
                    imageFiles.forEach((file) => {
                      contentArray.push({
                        type: 'image_url',
                        image_url: {
                          url: `data:${file.apiData.mimeType};base64,${file.apiData.data}`,
                        },
                      });
                    });
                    content = contentArray;
                  } else {
                    // Gemini format
                    const images = imageFiles.map((file) => ({
                      inline_data: {
                        mime_type: file.apiData.mimeType,
                        data: file.apiData.data,
                      },
                    }));
                    content = [{ text: fullText }, ...images];
                  }
                } else {
                  content = fullText;
                }
              } else {
                // assistant
                content =
                  msg.finalAnswerText || msg.text || (msg.parts?.[0]?.text || '');
              }

              if (
                !content ||
                (Array.isArray(content) && content.length === 0) ||
                (typeof content === 'string' && !content.trim())
              ) {
                return null;
              }

              return { role, content };
            })
            .filter(Boolean);

          const firstUserIndex = openAiMessages.findIndex((m) => m.role === 'user');
          if (firstUserIndex > 0) {
            return openAiMessages.slice(firstUserIndex);
          }
          if (openAiMessages.length === 1 && openAiMessages[0].role === 'assistant') {
            return [];
          }
          return openAiMessages;
        };

        const handleStopGeneration = useCallback(() => {
          isStoppingGenerationRef.current = true;
        }, []);

        const addMessageToLocalChat = async (
          role,
          text,
          filesForDisplay,
          aiSpecificData = {}
        ) => {
          const messageId =
            Date.now().toString(36) + Math.random().toString(36).substring(2);
          const messagePartsForDisplay = [];
          if (text) messagePartsForDisplay.push({ text: text });
          const attachedFilesForLocalState = filesForDisplay.map((f) => ({
            id: f.id,
            name: f.name,
            type: f.type,
            apiData: f.apiData,
            isLoading: f.isLoading,
          }));

          const messageData = {
            id: messageId,
            role: role,
            parts:
              messagePartsForDisplay.length > 0 ? messagePartsForDisplay : [{ text: '' }],
            text: text || '',
            timestamp: new Date().getTime(),
            ...(role === 'user' &&
              attachedFilesForLocalState.length > 0 && {
                uiOnlyAttachedFiles: attachedFilesForLocalState,
              }),
            ...(role === 'model' &&
              aiSpecificData.modelUsed && { modelUsed: aiSpecificData.modelUsed }),
            ...(aiSpecificData.searchUsed && { searchUsed: true }),
          };

          setChatMessages((prev) => [...prev, messageData]);
          return messageId;
        };
        
        const performSerperSearch = async (query) => {
            try {
                const response = await fetch("https://google.serper.dev/search", {
                    method: "POST",
                    headers: {
                        'X-API-KEY': CONFIG.api.serper.apiKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ q: query, num: 10 }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Serper API failed with status ${response.status}`);
                }

                const data = await response.json();
                if (!data.organic || data.organic.length === 0) {
                    return { toolContent: "No results found.", sources: [] };
                }

                const sources = data.organic.map(item => ({
                    link: item.link,
                    title: item.title,
                    snippet: item.snippet,
                    favicon: item.favicon
                }));
                
                const toolContent = JSON.stringify(sources.map(s => ({ title: s.title, link: s.link, snippet: s.snippet })));

                return { toolContent, sources };
            } catch (error) {
                console.error("Serper Search Error:", error);
                return { toolContent: `Search failed with error: ${error.message}`, sources: [] };
            }
        };

        const callPollinationsAPI = async (messages, modelToUse) => {
            try {
                const openAIMessages = messages.map(msg => {
                    if (msg.role === 'system') {
                        return { role: 'system', content: msg.content };
                    } else if (msg.role === 'model' || msg.role === 'assistant') {
                        return { role: 'assistant', content: msg.content };
                    } else {
                        if (Array.isArray(msg.content)) {
                            const content = msg.content.map(part => {
                                if (part.text) {
                                    return { type: 'text', text: part.text };
                                } else if (part.inline_data) {
                                    return { type: 'image_url', image_url: { url: `data:${part.inline_data.mime_type};base64,${part.inline_data.data}` } };
                                }
                                return part;
                            });
                            return { role: 'user', content: content };
                        } else {
                            return { role: 'user', content: msg.content };
                        }
                    }
                });

                const response = await fetch(CONFIG.api.pollinations.baseUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: modelToUse,
                        messages: openAIMessages,
                        temperature: CONFIG.settings.temperature,
                        max_tokens: 8192,
                        token: CONFIG.api.pollinations.apiKey,
                        stream: false
                    })
                });

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    throw new Error(`Pollinations API failed with status ${response.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
                }
                const data = await response.json();
                return data.choices?.[0]?.message?.content || "Sorry, I couldn't generate a response.";
            } catch (error) {
                console.error("Pollinations API Error:", error);
                throw error;
            }
        };

        const simulateTypingEffect = async (targetAiMessageUiId, fullText) => {
          streamTextBuffer.current = '';
          for (const char of fullText) {
            if (isStoppingGenerationRef.current) break;
            streamTextBuffer.current += char;
            setChatMessages((prev) =>
              prev.map((msg) =>
                msg.id === targetAiMessageUiId
                  ? {
                      ...msg,
                      isLoading: true,
                      loadingText: '',
                      finalAnswerText: streamTextBuffer.current,
                      text: streamTextBuffer.current,
                      parts: [{ text: streamTextBuffer.current }],
                    }
                  : msg
              )
            );
            await new Promise((resolve) =>
              setTimeout(resolve, CONFIG.settings.streamingSpeedMs)
            );
          }
        };

        const _streamAiResponse = async (
          targetAiMessageUiId,
          historyForA4f,
          modelToUse
        ) => {
          isStoppingGenerationRef.current = false;
          setChatMessages((prev) =>
            prev.map((m) =>
              m.id === targetAiMessageUiId
                ? { ...m, isLoading: true, loadingText: "Thinking..." }
                : m
            )
          );
          
          const initialHistory = [
              { role: 'system', content: getSystemInstruction() },
              ...historyForA4f,
          ];
          
          const modelConfig = CONFIG.models.list.find(m => m.id === modelToUse);
          const provider = modelConfig?.provider || 'gemini';

          try {
            let initialContent = "";
            if (provider === 'gemini') {
                const geminiContents = initialHistory.map(msg => {
                    const role = msg.role === 'assistant' ? 'model' : 'user';
                    if (Array.isArray(msg.content)) {
                        const parts = msg.content.map(part => {
                            if (part.text) {
                                return { text: part.text };
                            } else if (part.inline_data) {
                                return { inline_data: part.inline_data };
                            }
                            return part;
                        });
                        return { role, parts };
                    } else {
                        return { role, parts: [{ text: msg.content }] };
                    }
                });

                const initialResponse = await fetch(`${CONFIG.api.gemini.baseUrl}/${modelToUse}:generateContent?key=${CONFIG.api.gemini.apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: geminiContents,
                        generationConfig: {
                            temperature: CONFIG.settings.temperature,
                            maxOutputTokens: 8192,
                        }
                    }),
                });
                if (!initialResponse.ok) {
                    const errorBody = await initialResponse.json().catch(() => ({}));
                    throw new Error(`Request failed with status ${initialResponse.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
                }
                const initialData = await initialResponse.json();
                initialContent = initialData.candidates?.[0]?.content?.parts?.[0]?.text || "";

            } else if (provider === 'pollinations') {
                initialContent = await callPollinationsAPI(initialHistory, modelToUse);
            }
            
            let finalAnswerText = "";
            const searchMatch = initialContent.match(/\[SEARCH: "([^"]+)"\]/);
            
            if (searchMatch && searchMatch[1]) {
                const searchQuery = searchMatch[1];
                setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, searchQuery: searchQuery, loadingText: null } : m));
                
                const { toolContent, sources } = await performSerperSearch(searchQuery);
                
                setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, sources: sources, showSourcesOnly: true, searchQuery: null } : m));

                await new Promise(resolve => setTimeout(resolve, 1000));
                if (isStoppingGenerationRef.current) throw new Error("Generation stopped");

                setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, sources: sources, showSourcesOnly: false, searchQuery: null, isAnalyzing: true } : m));
                
                const enhancedHistory = [
                    ...initialHistory,
                    {
                        role: 'user',
                        content: `${initialHistory[initialHistory.length - 1].content}\n\nSearch Results for "${searchQuery}":\n${toolContent}\n\nPlease use this information to answer my question in Roman Urdu. Don't mention the search process.`
                    }
                ];

                if (provider === 'gemini') {
                    const geminiContents = enhancedHistory.map(msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        if (Array.isArray(msg.content)) {
                            const parts = msg.content.map(part => (part.text ? { text: part.text } : (part.inline_data ? { inline_data: part.inline_data } : part)));
                            return { role, parts };
                        } else {
                            return { role, parts: [{ text: msg.content }] };
                        }
                    });

                    const response = await fetch(`${CONFIG.api.gemini.baseUrl}/${modelToUse}:generateContent?key=${CONFIG.api.gemini.apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiContents,
                            generationConfig: {
                                temperature: CONFIG.settings.temperature,
                                maxOutputTokens: 8192
                            }
                        }),
                    });

                    if (!response.ok) throw new Error("Search response request failed");
                    const data = await response.json();
                    finalAnswerText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't process the search results.";
                } else if (provider === 'pollinations') {
                    finalAnswerText = await callPollinationsAPI(enhancedHistory, modelToUse);
                }

            } else {
                finalAnswerText = initialContent;
            }

            setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isAnalyzing: false, showSourcesOnly: false, searchQuery: null } : m));
            
            await simulateTypingEffect(targetAiMessageUiId, finalAnswerText);
          
          } catch (err) {
            if (err.message !== 'Generation stopped') {
              console.error('AI stream error:', err);
              let errorTextForUser = `A network error occurred. Please check your connection and try again. (${err.message})`;
              setToast({ text: errorTextForUser, type: 'error' });
              setChatMessages((prev) =>
                prev.map((msg) =>
                  msg.id === targetAiMessageUiId
                    ? {
                        ...msg,
                        isLoading: false,
                        isError: true,
                        finalAnswerText: errorTextForUser,
                        text: errorTextForUser,
                        parts: [{ text: errorTextForUser }],
                        sources: null,
                        showSourcesOnly: false
                      }
                    : msg
                )
              );
            }
          } finally {
            if (isStoppingGenerationRef.current) {
              streamTextBuffer.current += '\n\n*Generation stopped by user.*';
            }
            setChatMessages((prev) =>
              prev.map((msg) =>
                msg.id === targetAiMessageUiId
                  ? {
                      ...msg,
                      isLoading: false,
                      isAnalyzing: false,
                      finalAnswerText: streamTextBuffer.current.trim(),
                      text: streamTextBuffer.current.trim(),
                      parts: [{ text: streamTextBuffer.current.trim() }],
                      showSourcesOnly: false
                    }
                  : msg
              )
            );
            isStoppingGenerationRef.current = false;
          }
        };

        const handleSendChatMessage = useCallback(
          async (messageText, filesToSendFromInput) => {
            if (!messageText.trim() && filesToSendFromInput.length === 0) return;

            if (filesToSendFromInput.some((f) => f.isLoading)) {
              setChatError('Please wait for all files to finish loading.');
              return;
            }
            setChatError(null);
            setIsChatLoading(true);

            const tempUserMessage = {
              id: 'temp_user_' + Date.now(),
              role: 'user',
              text: messageText,
              parts: messageText ? [{ text: messageText }] : [],
              timestamp: new Date().getTime(),
              uiOnlyAttachedFiles: filesToSendFromInput,
            };

            const modelConfig = CONFIG.models.list.find(m => m.id === selectedModel);
            const provider = modelConfig?.provider || 'gemini';
            const historyForA4f = getA4fHistory([...chatMessages, tempUserMessage], provider);

            await addMessageToLocalChat(
              'user',
              messageText,
              filesToSendFromInput
            );

            const aiPlaceholderUiId = Date.now().toString() + '_model_resp_temp_ui';
            const preliminaryAiPlaceholder = {
              id: aiPlaceholderUiId,
              role: 'model',
              text: '',
              parts: [{ text: '' }],
              finalAnswerText: '',
              timestamp: new Date().getTime(),
              isLoading: true,
              isError: false,
              sources: null,
              showSourcesOnly: false,
              modelUsed: selectedModel,
              searchUsed: true,
              searchQuery: null,
              isAnalyzing: false,
            };

            setChatMessages((prev) => [
              ...prev.filter((m) => m.id !== 'loading_chat_indicator'),
              preliminaryAiPlaceholder,
            ]);

            await _streamAiResponse(aiPlaceholderUiId, historyForA4f, selectedModel);

            setIsChatLoading(false);
          },
          [chatMessages, currentChatId, selectedModel]
        );
        
        const handleRegenerateLastTextMessage = useCallback(async (aiMessageIdToRegenerate) => {
            setChatError(null);
            setIsChatLoading(true);

            const messagesSnapshot = [...chatMessages];
            let userPromptIndex = -1;
            const aiMessageIndex = messagesSnapshot.findIndex(m => m.id === aiMessageIdToRegenerate);
            
            if (aiMessageIndex === -1) {
                setToast({ text: "Cannot regenerate: Original AI message not found.", type: 'error' });
                setIsChatLoading(false);
                return;
            }

            const modelUsedForOriginal = messagesSnapshot[aiMessageIndex].modelUsed || selectedModel;

            for (let i = aiMessageIndex - 1; i >= 0; i--) {
                if (messagesSnapshot[i].role === 'user') {
                    userPromptIndex = i;
                    break;
                }
            }
            
            if (userPromptIndex === -1) {
                setToast({ text: "Cannot regenerate: Original user prompt not found.", type: 'error' });
                setIsChatLoading(false);
                return;
            }

            const modelConfig = CONFIG.models.list.find(m => m.id === modelUsedForOriginal);
            const provider = modelConfig?.provider || 'gemini';
            const historyForApi = getA4fHistory(messagesSnapshot.slice(0, userPromptIndex + 1), provider);
            
            const newAiMessageId = Date.now().toString() + '_model_regen_ui';
            setChatMessages(prev => prev.map(msg => 
                msg.id === aiMessageIdToRegenerate
                    ? {
                        id: newAiMessageId,
                        role: 'model',
                        text: '',
                        parts: [{ text: '' }],
                        finalAnswerText: "",
                        timestamp: new Date().getTime(),
                        isLoading: true,
                        isError: false,
                        sources: null,
                        modelUsed: modelUsedForOriginal,
                        searchUsed: true,
                        showSourcesOnly: false,
                        searchQuery: null,
                        isAnalyzing: false,
                    }
                    : msg
            ));

            await _streamAiResponse(newAiMessageId, historyForApi, modelUsedForOriginal);
            setIsChatLoading(false);

        }, [chatMessages, currentChatId, selectedModel]);
        
        const handleDeleteAiMessagePair = async (aiMessageId) => {
            const currentMessages = [...chatMessages];
            const aiMessageIndex = currentMessages.findIndex(msg => msg.id === aiMessageId);

            if (aiMessageIndex === -1) {
                setToast({ text: "Could not find the AI message to delete.", type: 'error' });
                return;
            }

            let idsToDelete = [aiMessageId];
            if (aiMessageIndex > 0) {
                let precedingUserMessage = null;
                for(let i = aiMessageIndex - 1; i >= 0; i--) {
                    if (currentMessages[i].role === 'model') {
                        break;
                    }
                    if (currentMessages[i].role === 'user') {
                        let interveningUserMessage = false;
                        for(let k = i + 1; k < aiMessageIndex; k++) {
                           if (currentMessages[k].role === 'user') {
                               interveningUserMessage = true;
                               break;
                           }
                        }
                        if (!interveningUserMessage) {
                            precedingUserMessage = currentMessages[i];
                        }
                        break;
                    }
                }
                if (precedingUserMessage) {
                    idsToDelete.push(precedingUserMessage.id);
                }
            }

            setChatMessages(prev => prev.filter(msg => !idsToDelete.includes(msg.id)));
        };

        const handleStartEdit = (id, currentText) => {
            setEditingMessageId(id);
            setEditText(currentText || '');
        };

        const handleCancelEdit = () => {
            setEditingMessageId(null);
            setEditText('');
        };

        const handleSaveEdit = (id) => {
            setChatMessages(prev => prev.map(msg => 
                msg.id === id 
                    ? { ...msg, finalAnswerText: editText, text: editText, parts: [{ text: editText }] } 
                    : msg
            ));
            handleCancelEdit();
        };

        if (authLoading) {
          return (
            <div className="h-full flex items-center justify-center bg-surface-main">
              <div className="w-10 h-10 border-4 border-brand-primary border-t-transparent rounded-full animate-spin-continuous"></div>
            </div>
          );
        }

        return (
          <div className="h-full text-text-primary flex font-sans bg-surface-main relative">
            {toast && (
              <div className="absolute top-5 left-1/2 -translate-x-1/2 z-50">
                <Toast
                  message={toast.text}
                  type={toast.type}
                  onDismiss={() => setToast(null)}
                />
              </div>
            )}
            <div className="flex-grow h-full flex flex-col min-w-0">
              <ChatInterface
                messages={chatMessages}
                onSendMessage={handleSendChatMessage}
                isLoading={isChatLoading}
                onStopGeneration={handleStopGeneration}
                onRegenerateLastTextMessage={handleRegenerateLastTextMessage}
                onNewChat={handleNewChat}
                setChatError={setChatError}
                currentChatId={currentChatId}
                onDeleteAiMessagePair={handleDeleteAiMessagePair}
                selectedUserMessageId={selectedUserMessageId}
                setSelectedUserMessageId={setSelectedUserMessageId}
                editingMessageId={editingMessageId}
                editText={editText}
                setEditText={setEditText}
                onSaveEdit={handleSaveEdit}
                onCancelEdit={handleCancelEdit}
                onStartEdit={handleStartEdit}
                selectedModel={selectedModel}
                setSelectedModel={setSelectedModel}
                setToast={setToast}
              />
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
