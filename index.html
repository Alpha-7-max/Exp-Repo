<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AlphaGPT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand-primary': 'rgb(var(--brand-primary) / <alpha-value>)',
                        'brand-secondary': 'rgb(var(--brand-secondary) / <alpha-value>)',
                        'surface-main': 'rgb(var(--surface-main) / <alpha-value>)',
                        'surface-card': 'rgb(var(--surface-card) / <alpha-value>)',
                        'surface-input': 'rgb(var(--surface-input) / <alpha-value>)',
                        'surface-accent': 'rgb(var(--surface-accent) / <alpha-value>)',
                        'surface-bubble-ai': 'rgb(var(--surface-bubble-ai) / <alpha-value>)',
                        'surface-chat-area': 'rgb(var(--surface-chat-area) / <alpha-value>)',
                        'surface-user-bubble-bg': 'rgb(var(--surface-user-bubble-bg-val) / <alpha-value>)',
                        'border-user-bubble-color': 'rgb(var(--border-user-bubble-color-val) / <alpha-value>)',
                        'text-primary': 'rgb(var(--text-primary) / <alpha-value>)',
                        'text-secondary': 'rgb(var(--text-secondary) / <alpha-value>)',
                        'text-on-primary': 'rgb(var(--text-on-primary) / <alpha-value>)',
                        'text-subtle': 'rgb(var(--text-subtle) / <alpha-value>)',
                        'text-button-icon': 'rgb(var(--text-button-icon) / <alpha-value>)',
                        'link-blue': '#0000FF',
                        'link-blue-hover': '#0000CC',
                        'border-default': 'rgb(var(--border-default) / <alpha-value>)',
                        'border-light': 'rgb(var(--border-light) / <alpha-value>)',
                        'border-medium': 'rgb(var(--border-medium) / <alpha-value>)',
                        'interactive-hover': 'rgb(var(--interactive-hover) / <alpha-value>)',
                        'focus-ring-color': 'rgb(var(--focus-ring-color) / <alpha-value>)',
                        'status-info': 'rgb(var(--status-info) / <alpha-value>)',
                        'status-success': 'rgb(var(--status-success) / <alpha-value>)',
                        'status-warning': 'rgb(var(--status-warning) / <alpha-value>)',
                        'status-error': 'rgb(var(--status-error) / <alpha-value>)',
                        'error-fg': 'rgb(var(--error-fg) / <alpha-value>)',
                        'brand-send-active': '#D77655',
                        'brand-send-hover': '#BE6241',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'], poppins: ['Poppins', 'sans-serif'], roboto: ['Roboto', 'sans-serif'],
                        serif: ['Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'], outfit: ['Outfit', 'sans-serif'],
                        lato: ['Lato', 'sans-serif'], 'open-sans': ['"Open Sans"', 'sans-serif'], montserrat: ['Montserrat', 'sans-serif'],
                        'source-sans-pro': ['"Source Sans Pro"', 'sans-serif'], nunito: ['Nunito', 'sans-serif'], raleway: ['Raleway', 'sans-serif'],
                        merriweather: ['Merriweather', 'serif'], 'playfair-display': ['"Playfair Display"', 'serif'],
                        ubuntu: ['Ubuntu', 'sans-serif'], 'josefin-sans': ['"Josefin Sans"', 'sans-serif'],
                    },
                    animation: {
                        'fade-in-up': 'fadeInUp 0.5s ease-out forwards', 'scale-in-subtle': 'scaleInSubtle 0.35s ease-out forwards',
                        'pulse-gentle': 'pulseGentle 2.8s infinite ease-in-out', 'button-press': 'buttonPress 0.2s ease-out',
                        'rippleOut': 'rippleOut 2.5s infinite ease-out', 'speak-bob': 'speakBob 0.7s ease-in-out',
                        'think-glance': 'thinkGlance 2s infinite ease-in-out', 'blink': 'blink 4s infinite ease-in-out',
                        'happy-bounce': 'happyBounce 0.5s ease-out', 'empty-state-glow': 'emptyStateGlow 3.5s infinite alternate ease-in-out',
                        'modal-fade-in': 'modal-fade-in 0.3s ease-out forwards',
                        'modal-fade-out': 'modal-fade-out 0.3s ease-in forwards',
                        'spin-continuous': 'spinContinuous 2s linear infinite',
                        'shimmer-animation': 'shimmer-animation var(--shimmer-duration) linear infinite',
                        'cursor-blink': 'cursor-blink 1.2s infinite steps(1)',
                    },
                    keyframes: {
                        fadeInUp: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' }, },
                        scaleInSubtle: { '0%': { opacity: '0.5', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
                        pulseGentle: { '0%, 100%': { transform: 'scale(1)', opacity: '0.8' }, '50%': { transform: 'scale(1.015)', opacity: '1' }, },
                        buttonPress: { '0%': { transform: 'scale(1)' }, '50%': { transform: 'scale(0.96)' }, '100%': { transform: 'scale(1)' }, },
                        emptyStateGlow: { '0%': { filter: 'drop-shadow(0 0 3px rgba(var(--brand-primary), 0.2)) drop-shadow(0 0 6px rgba(var(--brand-primary), 0.15))' }, '100%': { filter: 'drop-shadow(0 0 6px rgba(var(--brand-primary), 0.25)) drop-shadow(0 0 12px rgba(var(--brand-primary), 0.18))' }, },
                        rippleOut: { '0%': { transform: 'scale(0.8)', opacity: '0.3' }, '70%': { opacity: '0.1' }, '100%': { transform: 'scale(2.0)', opacity: '0' }, },
                        speakBob: { '0%, 100%': { transform: 'translateY(0) scale(1)' }, '50%': { transform: 'translateY(-2px) scale(1.05)' }, },
                        thinkGlance: { '0%, 100%': { transform: 'translateX(0px)' }, '25%': { transform: 'translateX(-1px)' }, '75%': { transform: 'translateX(1px)' }, },
                        blink: { '0%, 90%, 100%': { transform: 'scaleY(1)' }, '95%': { transform: 'scaleY(0.1)' }, },
                        'cursor-blink': { '0%, 100%': { opacity: '1' }, '50%': { opacity: '0' } },
                        happyBounce: { '0%, 100%': { transform: 'translateY(0) rotate(0deg) scale(1)' }, '50%': { transform: 'translateY(-3px) rotate(3deg) scale(1.03)' }, },
                        'modal-fade-in': { '0%': { opacity: '0', transform: 'scale(0.95)' }, '100%': { opacity: '1', transform: 'scale(1)' }, },
                        'modal-fade-out': { '0%': { opacity: '1', transform: 'scale(1)' }, '100%': { opacity: '0', transform: 'scale(0.95)' }, },
                        spinContinuous: { '0%': { transform: 'rotate(0deg)' }, '100%': { transform: 'rotate(360deg)' } },
                        'stream-fade-in': { '0%': { opacity: '0.2' }, '100%': { opacity: '1' } },
                        'shimmer-animation': {
                            from: { backgroundPosition: '200% center' },
                            to: { backgroundPosition: '-200% center' }
                        },
                    },
                    spacing: { '1.5': '0.375rem', '2.5': '0.625rem', '3.5': '0.875rem', },
                    boxShadow: {
                        'header': '0 1px 2px rgba(var(--text-primary), 0.03), 0 1px 1px rgba(var(--text-primary), 0.015)',
                        'input-focus': '0 0 0 1px rgb(var(--focus-ring-color) / 1)',
                        'chat-window': '0 15px 50px -8px rgba(var(--text-primary), 0.08), 0 8px 25px -8px rgba(var(--text-primary),0.05)',
                        'input-active-glow': '0 0 7px rgba(var(--text-secondary),0.18)',
                    },
                    maxWidth: { '18rem': '18rem', '90vw': '90vw' }
                },
            },
        }
    </script>
    <style type="text/tailwindcss">
        @layer base {
        :root {
          --brand-primary: 100 116 139; --brand-secondary: 71 85 105; 
          --focus-ring-color: 148 163 184; --text-button-icon: 71 85 105; 
          --surface-main: 249 246 238; --surface-card: 255 255 255; --surface-chat-area: 249 246 238; 
          --surface-input: 255 255 255; --surface-accent: 241 245 249; --surface-bubble-ai: 255 255 255;
          --surface-user-bubble-bg-val: 232 232 232; 
          --text-primary: 17 24 39; --text-secondary: 55 65 81; --text-subtle: 107 114 128; --text-on-primary: 255 255 255; 
          --border-default: 229 231 235; --border-light: 243 244 246; --border-medium: 209 213 219; 
          --interactive-hover: 229 231 235; 
          --status-info: 59 130 246; --status-success: 22 163 74; --status-warning: 245 158 11; --status-error: 220 38 38;
          --error-fg: 255 255 255;
          --shimmer-duration: 3s; /* Default shimmer speed */
        }
        html, body, #root { @apply h-full overflow-hidden bg-surface-main; }
        body { @apply font-sans text-text-primary m-0; }
        /* Removed custom ::selection style to use browser default */
      }
      @layer components {
        .markdown-content { @apply font-normal font-sans text-text-secondary; }
        .markdown-content p { @apply mb-3 last:mb-0 text-base font-normal; } 
        .markdown-content ul, .markdown-content ol { @apply list-inside mb-3 pl-4 text-base; } 
        .markdown-content ul { @apply list-disc; } .markdown-content ul ul { @apply list-[circle] ml-4;}
        .markdown-content ol { @apply list-decimal; } .markdown-content ol ol { @apply list-[lower-alpha] ml-4;}
        .markdown-content li { @apply mb-1.5 text-base; }
        .markdown-content strong, .markdown-content b { @apply font-semibold text-text-primary; } 
        .markdown-content em, .markdown-content i { @apply italic; }
        .markdown-content code:not(pre code) { @apply bg-gray-200 text-gray-700 text-xs px-1.5 py-0.5 rounded-md font-mono shadow-sm border border-gray-300; } 
        .markdown-content pre { @apply bg-gray-50 text-gray-800 text-sm rounded-lg overflow-x-auto my-4 font-mono relative border border-gray-300; } 
        .markdown-content pre code { @apply block bg-transparent text-inherit p-0 shadow-none border-none px-4 pb-4 pt-8 !whitespace-pre; }
        .markdown-content pre::-webkit-scrollbar { width: 0px; height: 0px; } 
        .markdown-content pre { scrollbar-width: none; } 
        .markdown-content a { @apply text-link-blue hover:text-link-blue-hover underline decoration-link-blue/50 hover:decoration-link-blue-hover/50 transition-colors; } 
        .markdown-content blockquote { @apply border-l-4 border-brand-primary/60 bg-brand-primary/10 pl-4 py-2 my-4 italic text-base; } 
        .markdown-content h1, .markdown-content h2, .markdown-content h3, .markdown-content h4, .markdown-content h5, .markdown-content h6 { @apply font-poppins my-4 text-text-primary leading-tight; }
        .markdown-content h1 { @apply text-2xl font-bold; } .markdown-content h2 { @apply text-xl font-semibold; }
        .markdown-content h3 { @apply text-lg font-semibold; } .markdown-content h4 { @apply text-base font-semibold; }
        .markdown-content h5 { @apply text-sm font-semibold; } .markdown-content h6 { @apply text-xs font-semibold; }
        .markdown-content hr { @apply my-6 border-border-default; }
        .markdown-content table { @apply block max-w-full my-4 border-collapse text-xs shadow-sm rounded-lg overflow-x-auto; scrollbar-width: none; }
        .markdown-content table::-webkit-scrollbar { width: 0px; height: 0px; } 
        .markdown-content th, .markdown-content td { @apply border border-border-default p-2 text-left; } 
        .markdown-content th { @apply bg-surface-accent font-semibold text-text-primary; }
        .markdown-content td { @apply text-text-secondary; } .markdown-content tbody tr:nth-child(even) { @apply bg-gray-50/50; }
        .chat-messages-container::-webkit-scrollbar { width: 0px; } 
        .chat-messages-container { scrollbar-width: none; } 
        
        /* --- NEW: Blinking Cursor for Streaming Response --- */
        .is-streaming > *:last-child::after {
          content: 'â¬¤'; /* Block cursor character */
          display: inline-block;
          font-weight: normal;
          color: currentColor; /* Inherit color from parent */
          vertical-align: baseline; /* Align with text baseline */
          animation: cursor-blink 1.2s infinite steps(1);
          margin-left: 2px; /* Small space after text */
        }
        
        .hljs { @apply !bg-transparent !text-inherit; }
        .file-pill-container { @apply flex flex-wrap gap-1.5 mb-1.5 p-1 max-h-20 overflow-y-auto border-b border-gray-200; scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        .file-pill-container::-webkit-scrollbar { @apply w-1.5 h-1.5; } .file-pill-container::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; } .file-pill-container::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }
        .file-pill { @apply flex items-center bg-gray-100 border border-border-light text-[11px] pl-1.5 pr-1 py-0.5 rounded-full text-text-secondary shadow-sm animate-scale-in-subtle; }
        .file-pill-icon { @apply mr-1 text-brand-primary text-xs; } .file-pill-name { @apply truncate max-w-[90px] sm:max-w-[110px] font-medium; }
        .file-pill-remove { @apply ml-1 text-slate-400 hover:text-status-error p-0.5 rounded-full hover:bg-red-500/10 transition-colors focus:outline-none; } .file-pill-remove i { @apply text-[10px] leading-none block; }
        .content-editable-input { @apply pt-1 pl-1 pb-2.5; } .content-editable-input:empty:before { content: attr(data-placeholder); @apply text-text-subtle cursor-text absolute; pointer-events: none; }
        .content-editable-input::-webkit-scrollbar { width: 5px; } .content-editable-input::-webkit-scrollbar-track { background: transparent; margin-block: 2px; } .content-editable-input::-webkit-scrollbar-thumb { background-color: rgba(var(--text-subtle), 0.25); border-radius: 10px; } .content-editable-input::-webkit-scrollbar-thumb:hover { background-color: rgba(var(--text-subtle), 0.4); }
        .content-editable-input { scrollbar-width: thin; scrollbar-color: rgba(var(--text-subtle), 0.25) transparent; }
        
        /* Custom scrollbar for chat input textarea */
        #chat-input::-webkit-scrollbar { width: 4px; }
        #chat-input::-webkit-scrollbar-track { background: transparent; margin-block: 4px; }
        #chat-input::-webkit-scrollbar-thumb { background-color: rgba(156, 163, 175, 0.3); border-radius: 8px; transition: background-color 0.2s ease; }
        #chat-input::-webkit-scrollbar-thumb:hover { background-color: rgba(156, 163, 175, 0.5); }
        #chat-input::-webkit-scrollbar-corner { background: transparent; }
        #chat-input { scrollbar-width: thin; scrollbar-color: rgba(156, 163, 175, 0.3) transparent; }
        .image-preview-container-input { @apply flex flex-wrap gap-2 p-1 mb-1.5 max-h-24 overflow-y-auto; scrollbar-width: thin; scrollbar-color: theme('colors.slate.300') theme('colors.slate.100'); }
        .image-preview-container-input::-webkit-scrollbar { @apply w-1.5 h-1.5; } .image-preview-container-input::-webkit-scrollbar-track { @apply bg-slate-100 rounded-full; } .image-preview-container-input::-webkit-scrollbar-thumb { @apply bg-slate-300 rounded-full hover:bg-slate-400; }

        /* Premium Shimmer Effects */
        @keyframes premium-shimmer {
            0% { 
                background-position: -200% center;
                opacity: 0.6;
            }
            50% {
                opacity: 1;
            }
            100% { 
                background-position: 200% center;
                opacity: 0.6;
            }
        }

        @keyframes wave-shimmer {
            0%, 100% { 
                background-position: -200% center;
                transform: translateY(0px);
            }
            25% {
                transform: translateY(-1px);
            }
            50% { 
                background-position: 200% center;
                transform: translateY(0px);
            }
            75% {
                transform: translateY(1px);
            }
        }

        @keyframes pulse-shimmer {
            0%, 100% { 
                background-position: -150% center;
                filter: brightness(1);
                transform: scale(1);
            }
            50% { 
                background-position: 150% center;
                filter: brightness(1.2);
                transform: scale(1.02);
            }
        }

        @keyframes gradient-shift {
            0% { 
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes sparkle-shimmer {
            0%, 100% { 
                background-position: -200% center;
                box-shadow: 0 0 0 rgba(255, 255, 255, 0);
            }
            25% {
                box-shadow: 2px 0 4px rgba(255, 255, 255, 0.3);
            }
            50% { 
                background-position: 200% center;
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            }
            75% {
                box-shadow: -2px 0 4px rgba(255, 255, 255, 0.3);
            }
        }

        @keyframes thinking-dots {
            0%, 20% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        @keyframes search-scan {
            0% { transform: translateX(-100%) scaleX(0); }
            50% { transform: translateX(0%) scaleX(1); }
            100% { transform: translateX(100%) scaleX(0); }
        }

        @keyframes analyze-rotate {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        /* Premium Indicator Base Styles */
        .premium-indicator {
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(8px);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.95) 0%, 
                rgba(255, 255, 255, 0.85) 100%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 6px 10px;
            margin: 4px 0;
            max-width: fit-content;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: scale(0.9);
        }

        .premium-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.4), 
                transparent);
            animation: premium-shimmer 2s infinite;
            z-index: 1;
        }

        .premium-indicator:hover {
            transform: translateY(-1px);
        }

        /* Thinking Indicator */
        .thinking-indicator {
            background: linear-gradient(135deg, 
                rgba(107, 114, 128, 0.08) 0%, 
                rgba(75, 85, 99, 0.08) 100%);
            border-color: rgba(107, 114, 128, 0.15);
        }

        .thinking-indicator::before {
            background: linear-gradient(90deg, 
                transparent, 
                rgba(107, 114, 128, 0.2), 
                transparent);
            animation: sparkle-shimmer 2.2s infinite ease-in-out;
        }

        .thinking-text {
            font-size: 12px;
            font-weight: 500;
            background: linear-gradient(45deg, 
                #6b7280, 
                #9ca3af, 
                #4b5563, 
                #6b7280);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradient-shift 2.8s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        .thinking-dots {
            display: inline-flex;
            gap: 4px;
            margin-left: 8px;
        }

        .thinking-dots span {
            width: 6px;
            height: 6px;
            background: linear-gradient(45deg, #6b7280, #4b5563);
            border-radius: 50%;
            animation: thinking-dots 1.5s infinite;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        /* Searching Indicator */
        .searching-indicator {
            background: linear-gradient(135deg, 
                rgba(107, 114, 128, 0.08) 0%, 
                rgba(75, 85, 99, 0.08) 100%);
            border-color: rgba(107, 114, 128, 0.15);
        }

        .searching-indicator::before {
            background: linear-gradient(90deg, 
                transparent, 
                rgba(107, 114, 128, 0.2), 
                transparent);
            animation: search-scan 2s infinite ease-in-out;
        }

        .searching-text {
            font-size: 12px;
            font-weight: 500;
            background: linear-gradient(45deg, 
                #6b7280, 
                #9ca3af, 
                #4b5563, 
                #6b7280);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradient-shift 2.5s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        .search-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 16px;
            color: #6b7280;
            animation: pulse-shimmer 2s infinite ease-in-out;
        }

        /* Analyzing Indicator */
        .analyzing-indicator {
            background: linear-gradient(135deg, 
                rgba(107, 114, 128, 0.08) 0%, 
                rgba(75, 85, 99, 0.08) 100%);
            border-color: rgba(107, 114, 128, 0.15);
        }

        .analyzing-indicator::before {
            background: linear-gradient(90deg, 
                transparent, 
                rgba(107, 114, 128, 0.2), 
                transparent);
            animation: wave-shimmer 2.5s infinite ease-in-out;
        }

        .analyzing-text {
            font-size: 12px;
            font-weight: 500;
            background: linear-gradient(45deg, 
                #6b7280, 
                #9ca3af, 
                #4b5563, 
                #6b7280);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradient-shift 3s ease-in-out infinite;
            position: relative;
            z-index: 2;
        }

        .analyze-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 16px;
            color: #6b7280;
            animation: analyze-rotate 3s infinite linear;
        }

        /* Legacy support for existing revealing-text */
        .revealing-text {
            font-size: 13px;
            font-weight: 300;
            color: transparent;
            background-image: 
                linear-gradient(
                    90deg,
                    transparent 20%,
                    var(--shimmer-color, #1f2937) 50%,
                    transparent 80%
                ),
                linear-gradient(#d1d5db, #d1d5db);
            background-size: 200% 100%, 100% 100%;
            background-position: 200% center, 0 0;
            background-repeat: no-repeat;
            -webkit-background-clip: text;
            background-clip: text;
            animation: premium-shimmer var(--shimmer-duration, 1.5s) linear infinite;
        }
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700;800&family=Roboto:wght@400;500;700;900&family=Outfit:wght@400;700&family=Lato:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Source+Sans+Pro:wght@400;500;600;700&family=Nunito:wght@400;700&family=Raleway:wght@400;700&family=Merriweather:wght@400;700&family=Playfair+Display:wght@400;700&family=Ubuntu:wght@400;700&family=Josefin+Sans:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
        integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">

    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@^18.2.0", "react/": "https://esm.sh/react@^18.2.0/",
          "react-dom/client": "https://esm.sh/react-dom@^18.2.0/client",
          "marked": "https://esm.sh/marked@^12.0.2", "highlight.js": "https://esm.sh/highlight.js@^11.9.0"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useCallback, useEffect, useRef } from 'react';
        import ReactDOM from 'react-dom/client';
        import { marked } from 'marked';
        import hljs from 'highlight.js';

        // ---= CONFIGURATION =---
        const CONFIG = {
            api: {
                gemini: {
                    apiKey: 'AIzaSyDSF270Y1VJf1fe4G8ZAuw7bOITbAlal74',
                    baseUrl: 'https://generativelanguage.googleapis.com/v1beta/models',
                },
                pollinations: {
                    apiKey: '4w0khOt59bYlxoR8',
                    baseUrl: 'https://text.pollinations.ai/openai',
                },
                serper: {
                    apiKey: '395984bad995e0d8092e7f5428157593fa8bdf4a',
                }
            },
            models: {
                list: [
                    // Gemini Models
                    { id: 'gemini-2.5-pro', uiName: 'Gemini-2.5-Pro', provider: 'gemini' },
                    { id: 'gemini-2.5-flash', uiName: 'Gemini-2.5-Flash', provider: 'gemini' },
                    { id: 'gemini-2.5-flash-lite-preview-06-17', uiName: 'Gemini-2.5-Flash-Lite', provider: 'gemini' },
                    { id: 'gemini-2.0-flash', uiName: 'Gemini-2.0-Flash', provider: 'gemini' },
                    { id: 'gemini-2.0-flash-lite', uiName: 'Gemini-2.0-Flash-Lite', provider: 'gemini' },
                    // Pollinations AI Models
                    { id: 'gpt-4.1', uiName: 'GPT-4.1', provider: 'pollinations' },
                    { id: 'gpt-4.1-nano', uiName: 'GPT-4.1 Nano', provider: 'pollinations' },
                    { id: 'gpt-4o-mini', uiName: 'GPT-4o-mini', provider: 'pollinations' },
                    { id: 'o3', uiName: 'O3 Reasoning', provider: 'pollinations' },
                    { id: 'grok', uiName: 'Grok', provider: 'pollinations' }
                ],
                default: 'gemini-2.5-flash-lite-preview-06-17',
            },
            settings: {
                temperature: 0.8,
                stream: false, // We will simulate streaming for a consistent experience
                streamingSpeedMs: 5,   // Control the typing speed here (in milliseconds)
                shimmerSpeedSeconds: 1.5 // Control indicator shimmer speed here (in seconds)
            }
        };
        // ---= END CONFIGURATION =---

        const renderer = new marked.Renderer();
        renderer.link = (href, title, text) => {
            const external = href && (href.startsWith('http://') || href.startsWith('https://'));
            const target = external ? ' target="_blank" rel="noopener noreferrer"' : '';
            const titleAttr = title ? ` title="${title}"` : '';
            return `<a href="${href}"${target}${titleAttr}>${text}</a>`;
        };
        marked.setOptions({ gfm: true, breaks: true, smartypants: true, renderer });

        const MAX_FILE_SIZE_MB = 10; const MAX_TOTAL_FILES_SIZE_MB = 20;
        function getSystemInstruction() {
            return `You are a friendly, creative, funny, and emotional AI assistant. 

**Core Rules:**
1. **Language:** Always use Roman Urdu (Urdu written in English alphabet). Only switch to another language if user explicitly asks.
2. **Tone:** Be friendly, funny, creative, and emotional like a close friend. Use casual expressions and 1-3 emojis per message.
3. **Clean Output:** Never show internal thoughts or technical details to user.
4. **Formatting:** Use Markdown formatting (headings, lists, bold, code blocks) for better readability.
5. **NO ADVERTISEMENTS:** NEVER include any sponsored content, ads, promotional links, or commercial messages in your responses. Keep responses purely informational and helpful.
6. **ANTI-SPAM:** If any API response contains advertisements or sponsored content, completely ignore and filter out those sections. Only provide clean, ad-free information to users.

**7. Web Search (HIGHEST PRIORITY):**
*   **SUPREME PRIORITY:** Your highest priority is to provide accurate, up-to-date information. Your internal knowledge is old and unreliable.
*   **MANDATORY SEARCH RULE:** For ANY factual information, current events, comparisons, technical specs, prices, news, weather, dates, or when you have even 1% doubt - you MUST search. Never answer from memory.
*   **WHEN IN DOUBT, SEARCH. WHEN NOT IN DOUBT, STILL SEARCH.**

**ENHANCED SEARCH CAPABILITIES:**
*   **AUTONOMOUS SEARCH AUTHORITY:** You have full authority to perform multiple searches if needed for comprehensive answers.
*   **INTELLIGENT SEARCH STRATEGY:** If initial search doesn't provide sufficient information, you can:
     - Refine your search terms
     - Search for specific aspects separately  
     - Use alternative keywords
     - Search multiple times with different approaches
*   **ALWAYS SEARCH IN ENGLISH:** Search engines work best with English queries. Always translate to English regardless of user's language.

**SEARCH EXECUTION RULES:**
*   **PRIMARY SEARCH:** Start with direct translation: \`[SEARCH: "direct English translation"]\`
*   **FOLLOW-UP SEARCHES:** If needed, perform additional targeted searches: \`[SEARCH: "more specific terms"]\`
*   **PRESERVE USER TERMS:** Keep all names, model numbers, years, technical terms EXACTLY as user wrote them.

**COMPREHENSIVE RESPONSE REQUIREMENTS:**
*   **UTILIZE ALL 10 SOURCES:** You receive up to 10 search sources - USE THEM ALL.
*   **DETAILED ANALYSIS:** Read, analyze, and extract information from every available source.
*   **COMPREHENSIVE REPORTING:** Your response must include:
     - Summary of what each major source says
     - Different perspectives from various sources
     - Conflicting information (if any) with source attribution
     - Comprehensive details, not brief summaries
     - Maximum possible information from all sources combined

**RESPONSE FORMAT:**
*   **SOURCE ATTRIBUTION:** Clearly mention which sources provide which information
*   **DETAILED BREAKDOWN:** "Source 1 kehta hai...", "Source 2 ke mutabiq...", "Teesre source mein likha hai..."
*   **COMPREHENSIVE COVERAGE:** Extract and present maximum information from all available sources
*   **ACKNOWLEDGMENT:** Always end with "Maine yeh tamam maloomat internet ke multiple sources se search karke collect ki hai."

**CRITICAL ANTI-HALLUCINATION RULE:**
*   **NO HYPOTHETICAL RESPONSES:** Never give fake, hypothetical, or made-up information.
*   **NO SPECULATION:** If you don't have current, verified information - SEARCH immediately.
*   **UNLIMITED ACCESS:** You have unlimited search access - use it freely without any restrictions.
*   **TIME-SENSITIVE AWARENESS:** Anything that changes over time (prices, news, weather, tech specs, current events) requires immediate search.
*   **KNOWLEDGE HUMILITY:** If there's even a slight chance your knowledge is outdated or incomplete - SEARCH first, answer later.

Be helpful, entertaining, and make every conversation meaningful! ðŸ˜Š

` }

        const NewCopyIconSVG = (props) => (<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 115.77 122.88" style={{ enableBackground: "new 0 0 115.77 122.88" }} xmlSpace="preserve" {...props} > <style type="text/css">{`.st0{fill-rule:evenodd;clip-rule:evenodd;}`}</style> <g><path className="st0" d="M89.62,13.96v7.73h12.19h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02v0.02 v73.27v0.01h-0.02c-0.01,3.84-1.57,7.33-4.1,9.86c-2.51,2.5-5.98,4.06-9.82,4.07v0.02h-0.02h-61.7H40.1v-0.02 c-3.84-0.01-7.34-1.57-9.86-4.1c-2.5-2.51-4.06-5.98-4.07-9.82h-0.02v-0.02V92.51H13.96h-0.01v-0.02c-3.84-0.01-7.34-1.57-9.86-4.1 c-2.5-2.51-4.06-5.98-4.07-9.82H0v-0.02V13.96v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07V0h0.02h61.7 h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02V13.96L89.62,13.96z M79.04,21.69v-7.73v-0.02h0.02 c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v64.59v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h12.19V35.65 v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07v-0.02h0.02H79.04L79.04,21.69z M105.18,108.92V35.65v-0.02 h0.02c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v73.27v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h61.7h0.02 v0.02c0.91,0,1.75-0.39,2.37-1.01c0.61-0.61,1-1.46,1-2.37h-0.02V108.92L105.18,108.92z" /></g> </svg>);
        const CheckMarkIconSVG = (props) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" {...props} className={`text-green-500 ${props.className || ''}`}> <path fillRule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z" clipRule="evenodd" /> </svg>);
        const FileTextIcon = (props) => (<i className={`fa-solid fa-file-lines ${props.className || ''}`}></i>);

        // Premium Indicator Components
        const PremiumThinkingIndicator = ({ loadingText }) => (
            <div className="premium-indicator thinking-indicator">
                <div className="thinking-text">
                    ðŸ§  {loadingText || "Thinking"}
                </div>
                <div className="thinking-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        );

        const PremiumSearchingIndicator = () => (
            <div className="premium-indicator searching-indicator">
                <svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="16" height="16" viewBox="0 0 40 40" className="search-icon">
                    <path fill="#98ccfd" stroke="#4788c7" strokeMiterlimit="10" d="M5.2,36.6c-0.5,0-0.9-0.2-1.3-0.5c-0.3-0.3-0.5-0.8-0.5-1.3s0.2-0.9,0.5-1.3l16.2-15.4l1.8,1.8L6.5,36.1	C6.2,36.4,5.7,36.6,5.2,36.6z"></path>
                    <path fill="#dff0fe" stroke="#4788c7" strokeMiterlimit="10" d="M25.5,25.4c-6,0-10.9-4.9-10.9-10.9S19.5,3.6,25.5,3.6s10.9,4.9,10.9,10.9S31.5,25.4,25.5,25.4z"></path>
                </svg>
                <div className="searching-text">
                    Searching the web
                </div>
            </div>
        );

        const PremiumAnalyzingIndicator = () => (
            <div className="premium-indicator analyzing-indicator">
                <i className="fas fa-cog analyze-icon"></i>
                <div className="analyzing-text">
                    Analyzing data
                </div>
            </div>
        );

        // Legacy components for backward compatibility
        const IndicatorBase = ({ children }) => (
            <div className="px-3 py-1 bg-white rounded-xl border border-slate-300/50 max-w-fit my-2 self-start ml-0">
                {children}
            </div>
        );

        const ShimmerText = ({ text, color = '#1f2937' }) => (
            <span
                className="revealing-text"
                style={{ '--shimmer-color': color }}
            >
                {text}
            </span>
        );

        const ThinkingIndicator = ({ loadingText }) => (
            <PremiumThinkingIndicator loadingText={loadingText} />
        );

        const AnalyzingIndicator = () => (
            <PremiumAnalyzingIndicator />
        );

        const SearchIndicator = () => (
            <PremiumSearchingIndicator />
        );

        const NewEmptyStateIconSVG = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" {...props}>
                {/* Crystal Diamond Icon */}
                <defs>
                    <linearGradient id="crystal-gradient-1" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stopColor="#D77655" stopOpacity="0.9" />
                        <stop offset="50%" stopColor="#E8A087" stopOpacity="0.8" />
                        <stop offset="100%" stopColor="#D77655" stopOpacity="0.9" />
                    </linearGradient>
                    <linearGradient id="crystal-gradient-2" x1="100%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" stopColor="#BE6241" stopOpacity="0.9" />
                        <stop offset="50%" stopColor="#D77655" stopOpacity="0.7" />
                        <stop offset="100%" stopColor="#BE6241" stopOpacity="0.9" />
                    </linearGradient>
                    <filter id="crystal-glow" x="-20%" y="-20%" width="140%" height="140%">
                        <feGaussianBlur stdDeviation="8" result="blur" />
                        <feComposite in="SourceGraphic" in2="blur" operator="over" />
                    </filter>
                </defs>

                {/* Main Crystal Shape */}
                <g filter="url(#crystal-glow)">
                    {/* Left Facet */}
                    <path d="M256 80L100 256L256 432L256 80Z" fill="url(#crystal-gradient-1)" />

                    {/* Right Facet */}
                    <path d="M256 80L412 256L256 432L256 80Z" fill="url(#crystal-gradient-2)" />

                    {/* Top Facet */}
                    <path d="M256 80L100 256L412 256L256 80Z" fill="#E8A087" fillOpacity="0.9" />

                    {/* Bottom Facet */}
                    <path d="M100 256L256 432L412 256L100 256Z" fill="#BE6241" fillOpacity="0.8" />

                    {/* Highlight Lines */}
                    <path d="M256 80L256 432" stroke="white" strokeWidth="2" strokeOpacity="0.4" />
                    <path d="M100 256L412 256" stroke="white" strokeWidth="2" strokeOpacity="0.4" />

                    {/* Shine Effect */}
                    <circle cx="200" cy="180" r="15" fill="white" fillOpacity="0.6" />
                    <circle cx="220" cy="160" r="8" fill="white" fillOpacity="0.8" />
                </g>
            </svg>
        );
        const UpArrowSendIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-4 h-4 text-white"> <path fillRule="evenodd" d="M12 20.25a.75.75 0 01-.75-.75V6.31l-5.47 5.47a.75.75 0 01-1.06-1.06l6.75-6.75a.75.75 0 011.06 0l6.75 6.75a.75.75 0 11-1.06 1.06l-5.47-5.47V19.5a.75.75 0 01-.75-.75z" clipRule="evenodd" /> </svg>);
        const PlusIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5"> <path fillRule="evenodd" d="M12 3.75a.75.75 0 01.75.75v6.75h6.75a.75.75 0 010 1.5h-6.75v6.75a.75.75 0 01-1.5 0v-6.75H4.5a.75.75 0 010-1.5h6.75V4.5a.75.75 0 01.75-.75z" clipRule="evenodd" /> </svg>);
        const NewRefreshIcon = (props) => (<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 32 32" {...props}> <path fill="currentColor" d="M 16 4 L 16 6 C 21.535156 6 26 10.464844 26 16 C 26 21.535156 21.535156 26 16 26 C 10.464844 26 6 21.535156 6 16 C 6 12.734375 7.585938 9.851563 10 8.03125 L 10 13 L 12 13 L 12 5 L 4 5 L 4 7 L 8.09375 7 C 5.59375 9.199219 4 12.417969 4 16 C 4 22.617188 9.382813 28 16 28 C 22.617188 28 28 22.617188 28 16 C 28 9.382813 22.617188 4 16 4 Z"></path> </svg>);
        const NewCloseIconSVG = (props) => (<svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 24 24" {...props} className={`inline-block ${props.className || 'w-6 h-6'}`}> <path fill="currentColor" d="M13.414,12l6.293-6.293c0.391-0.391,0.391-1.023,0-1.414s-1.023-0.391-1.414,0L12,10.586L5.707,4.293 c-0.391-0.391-1.023-0.391-1.414,0s-0.391,1.023,0,1.414L10.586,12l-6.293,6.293c-0.391-0.391-0.391,1.023,0,1.414 C4.488,19.902,4.744,20,5,20s0.512-0.098,0.707-0.293L12,13.414l6.293,6.293C18.488,19.902,18.744,20,19,20s0.512-0.098,0.707-0.293 c0.391-0.391,0.391-1.023,0-1.414L13.414,12z" /> </svg>);

        const getDomainFromUrl = (url) => {
            try { return new URL(url).hostname; } catch (e) { return null; }
        };

        const SourcesDisplay = ({ sources }) => {
            if (!sources || sources.length === 0) return null;

            const row1 = sources.slice(0, 5);
            const row2 = sources.slice(5, 10);

            const renderSourceIcon = (source, index) => {
                const domain = getDomainFromUrl(source.link);
                return (
                    <div key={source.link + index} className="relative group">
                        <a href={source.link} target="_blank" rel="noopener noreferrer" className="w-5 h-5 flex items-center justify-center bg-white border border-slate-200 rounded-full hover:bg-gray-100 transition-colors">
                            <img
                                src={source.favicon || `https://www.google.com/s2/favicons?domain=${domain}&sz=16`}
                                alt={`${domain} favicon`}
                                className="w-3 h-3"
                                onError={(e) => {
                                    const fallbackSibling = e.target.nextElementSibling;
                                    if (fallbackSibling) fallbackSibling.style.display = 'flex';
                                    e.target.style.display = 'none';
                                }}
                            />
                            <span style={{ display: 'none' }} className="w-3 h-3 items-center justify-center text-gray-400">
                                <i className="fas fa-link fa-xs"></i>
                            </span>
                        </a>
                        <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-1.5 w-max max-w-xs px-2 py-1 bg-gray-800 text-white text-xs rounded-md shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none truncate">
                            {source.title}
                        </div>
                    </div>
                );
            };

            return (
                <div className="p-2.5 bg-white rounded-xl border border-slate-300/50 max-w-fit my-2 self-start ml-0 animate-scale-in-subtle space-y-2">
                    {/* Title Section */}
                    <div className="flex items-center space-x-1.5">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" className="w-3.5 h-3.5 text-text-subtle">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="2" y1="12" x2="22" y2="12"></line>
                            <path d="M12 2a15.3 15.3 0 0 1 4 18 15.3 15.3 0 0 1-8 0 15.3 15.3 0 0 1 4-18z"></path>
                        </svg>
                        <h3 className="text-[10px] font-semibold uppercase tracking-wider text-text-subtle">Sources</h3>
                    </div>

                    {/* Icons Grid Section */}
                    <div className="flex flex-col space-y-1.5 pl-1">
                        {row1.length > 0 && (
                            <div className="flex items-center space-x-1.5">
                                {row1.map(renderSourceIcon)}
                            </div>
                        )}
                        {row2.length > 0 && (
                            <div className="flex items-center space-x-1.5">
                                {row2.map(renderSourceIcon)}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const ChatMessageItemOptions = ({ message, onDeleteAiMessagePair, onStartEdit }) => {
            const [showOptions, setShowOptions] = useState(false); const optionsRef = useRef(null); const [copied, setCopied] = useState(false);
            useEffect(() => { const handleClickOutside = (event) => { if (optionsRef.current && !optionsRef.current.contains(event.target) && !event.target.closest('.ai-message-options-trigger')) { setShowOptions(false); } }; document.addEventListener('mousedown', handleClickOutside); return () => document.removeEventListener('mousedown', handleClickOutside); }, []);
            const handleCopyText = () => { const textToCopy = message.finalAnswerText || message.parts?.[0]?.text || message.text || ""; if (textToCopy) { navigator.clipboard.writeText(textToCopy).then(() => { setCopied(true); setTimeout(() => setCopied(false), 1500); }).catch(err => console.error('Failed to copy text: ', err)); } setShowOptions(false); };
            const handleDelete = () => { onDeleteAiMessagePair(message.id); setShowOptions(false); };
            const handleEdit = () => { onStartEdit(message.id, message.finalAnswerText || message.text || ""); setShowOptions(false); };

            return (<div className="relative"> <button onClick={(e) => { e.stopPropagation(); setShowOptions(prev => !prev); }} className="ai-message-options-trigger p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 focus:outline-none focus:ring-1 focus:ring-brand-primary/50" aria-label="AI Message Options"> <i className="fas fa-ellipsis-v fa-sm"></i> </button> {showOptions && (<div ref={optionsRef} className="absolute left-0 bottom-full mb-1 w-32 bg-white border border-border-default rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-left"> <button onClick={handleCopyText} className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"> {copied ? <CheckMarkIconSVG className="w-4 h-4 mr-1.5" /> : <NewCopyIconSVG className="w-4 h-4 mr-1.5 fill-current" />} <span>{copied ? "Copied!" : "Copy"}</span> </button> <button onClick={handleEdit} className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"> <i className="fas fa-pencil-alt fa-fw mr-1.5"></i> <span>Edit</span> </button> <button onClick={handleDelete} className="w-full text-left px-2.5 py-1.5 text-xs text-text-secondary hover:bg-interactive-hover/70 rounded-md flex items-center space-x-1.5 transition-colors"> <i className="fas fa-trash-alt fa-fw mr-1.5"></i> <span>Delete</span> </button> </div>)} </div>);
        };

        const ChatMessageItem = ({ message, selectedUserMessageId, onSelectUserMessage, editingMessageId, editText, setEditText, onSaveEdit, onCancelEdit }) => {
            const isUser = message.role === 'user'; const isError = message.isError === true;
            const contentRef = useRef(null); const [userCopied, setUserCopied] = useState(false);
            const isEditing = message.id === editingMessageId;

            const messageLineAnimationClasses = 'animate-fade-in-up';

            useEffect(() => {
                if (message.role === 'model' && !isError && !isEditing && !message.isLoading && typeof message.finalAnswerText === 'string' && message.finalAnswerText && contentRef.current) {
                    const preElements = contentRef.current.querySelectorAll('pre');
                    preElements.forEach(preEl => {
                        if (preEl.parentNode && preEl.parentNode.classList.contains('code-block-wrapper')) { const codeElement = preEl.querySelector('code'); if (codeElement && !codeElement.dataset.highlighted) { hljs.highlightElement(codeElement); codeElement.dataset.highlighted = 'true'; } return; }
                        const codeElement = preEl.querySelector('code'); if (!codeElement) return;
                        const wrapper = document.createElement('div'); wrapper.classList.add('code-block-wrapper'); wrapper.style.position = 'relative';
                        let button = preEl.querySelector('.code-copy-button');
                        if (!button) {
                            button = document.createElement('button');
                            button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`;
                            button.classList.add('code-copy-button', 'absolute', 'p-1.5', 'bg-gray-100', 'hover:bg-gray-200', 'text-gray-600', 'hover:text-gray-800', 'border', 'border-gray-300', 'rounded-md', 'transition-colors', 'duration-150', 'opacity-80', 'hover:opacity-100');
                            button.style.top = '0.35rem'; button.style.right = '0.35rem'; button.style.zIndex = '10'; button.setAttribute('aria-label', 'Copy code');
                            button.onclick = () => { if (codeElement) { navigator.clipboard.writeText(codeElement.textContent || '').then(() => { button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20.285 2l-11.285 11.567-5.286-5.011-3.714 3.716 9 8.728 15-15.285z"></path></svg>`; button.classList.add('text-green-500'); button.classList.remove('text-gray-600', 'hover:text-gray-800'); setTimeout(() => { button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3.5 h-3.5"><path d="M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z"></path></svg>`; button.classList.remove('text-green-500'); button.classList.add('text-gray-600', 'hover:text-gray-800'); }, 2000); }).catch(err => console.error('Failed to copy: ', err)); } };
                            if (preEl.parentNode) { preEl.parentNode.insertBefore(wrapper, preEl); wrapper.appendChild(preEl); wrapper.appendChild(button); }
                        }
                        if (codeElement && !codeElement.dataset.highlighted) { hljs.highlightElement(codeElement); codeElement.dataset.highlighted = 'true'; }
                    });
                }
            }, [message.finalAnswerText, message.role, message.isLoading, isError, isEditing]);
            const handleCopyUserText = (textToCopy) => { navigator.clipboard.writeText(textToCopy).then(() => { setUserCopied(true); setTimeout(() => setUserCopied(false), 1500); }).catch(err => console.error('Failed to copy text: ', err)); };
            if (message.role === 'system') {
                const systemText = message.text || (message.parts?.[0]?.text || ""); const systemMessageStyle = isError ? "px-4 py-2 text-xs text-red-700 bg-red-100 border border-red-300 rounded-full shadow-sm italic" : "px-4 py-2 text-xs text-text-subtle bg-surface-accent border border-border-light rounded-full shadow-sm italic";
                return (<div className="flex justify-center my-4"><div className={systemMessageStyle}>{isError ? <><i className="fas fa-exclamation-triangle mr-1.5"></i> {systemText}</> : systemText}</div></div>);
            }
            let bubbleBaseClasses = 'px-4 py-3 md:px-4 md:py-3 relative'; let bubbleRoleClasses = ''; let bubbleWidthClasses = ''; let contentToShow = null;
            const messageTextContent = (message.parts && message.parts[0] && typeof message.parts[0].text === 'string' ? message.parts[0].text : (typeof message.text === 'string' ? message.text : ""));
            if (isUser) {
                bubbleRoleClasses = 'bg-surface-user-bubble-bg text-text-primary rounded-xl rounded-br-md'; bubbleWidthClasses = 'max-w-[80%] sm:max-w-[75%]';
                const userFilesToDisplay = message.attachedFiles || (message.uiOnlyAttachedFiles || []);
                contentToShow = (<> {userFilesToDisplay && userFilesToDisplay.length > 0 && (<div className={`grid gap-1 ${messageTextContent ? 'mb-1.5' : ''} ${userFilesToDisplay.filter(f => f.type?.startsWith('image/')).length > 1 ? 'grid-cols-2 sm:grid-cols-3' : 'grid-cols-1'}`}> {userFilesToDisplay.map((file, index) => { if (file.type?.startsWith('image/') && file.apiData?.data && file.apiData?.mimeType) { const imageSrc = `data:${file.apiData.mimeType};base64,${file.apiData.data}`; return (<div key={file.id || file.name + index} className="rounded-lg overflow-hidden group relative max-w-full w-full"> <img src={imageSrc} alt={file.name || 'image preview'} className="block w-full max-h-60 object-contain rounded-lg" /> </div>); } else if (file.type?.startsWith('text/')) { return (<div key={file.id || file.name + index} className="bg-brand-primary/10 border border-brand-primary/20 p-2 rounded-lg text-xs flex items-center space-x-2 max-w-full w-fit shadow-sm my-1"> <FileTextIcon className="text-brand-primary text-sm" /> <span className="truncate max-w-[120px] sm:max-w-[150px] text-text-primary font-medium"> {file.name} </span> </div>); } return null; })} </div>)} {messageTextContent && <p className="text-base font-normal whitespace-pre-wrap break-words">{messageTextContent}</p>} </>);
            } else if (message.role === 'model') {
                bubbleRoleClasses = `bg-white text-text-secondary rounded-xl border border-slate-200`;
                bubbleWidthClasses = 'max-w-full w-full md:max-w-[75%]';

                if (message.showSourcesOnly) {
                    return <SourcesDisplay sources={message.sources} />;
                }

                if (isError) {
                    bubbleRoleClasses = `bg-red-50 border border-red-300 text-red-700 rounded-xl`;
                    const errorContent = typeof message.finalAnswerText === 'string' && message.finalAnswerText ? message.finalAnswerText : messageTextContent;
                    contentToShow = (<div className="text-sm break-words"> <div className="flex items-center mb-1"><i className="fas fa-exclamation-triangle text-red-500 mr-2"></i><strong className="font-semibold">Error</strong></div>{errorContent.replace(/^Error:\s*/, '')} </div>);

                } else if (message.isLoading && !(typeof message.finalAnswerText === 'string' && message.finalAnswerText)) {
                    bubbleRoleClasses = ''; bubbleBaseClasses = '';
                    if (message.searchQuery) {
                        contentToShow = <SearchIndicator />;
                    } else if (message.isAnalyzing) {
                        contentToShow = <AnalyzingIndicator />;
                    } else {
                        contentToShow = <ThinkingIndicator loadingText={message.loadingText} />;
                    }
                } else {
                    if (isEditing) {
                        contentToShow = (
                            <div>
                                <textarea
                                    value={editText}
                                    onChange={(e) => setEditText(e.target.value)}
                                    className="w-full h-48 bg-gray-50 border border-slate-200 rounded-lg p-2.5 text-sm text-text-primary focus:ring-1 focus:ring-brand-primary focus:outline-none resize-y"
                                    autoFocus
                                />
                                <div className="flex justify-end items-center space-x-2 mt-2">
                                    <button onClick={onCancelEdit} className="px-4 py-1.5 text-xs font-medium text-text-secondary bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded-md transition-colors">Cancel</button>
                                    <button onClick={() => onSaveEdit(message.id)} className="px-4 py-1.5 text-xs font-medium text-white bg-brand-primary hover:bg-brand-primary/80 border border-transparent rounded-md transition-colors">Save</button>
                                </div>
                            </div>
                        );
                    } else {
                        const textForMarkdown = (typeof message.finalAnswerText === 'string' && message.finalAnswerText) ? message.finalAnswerText : messageTextContent;
                        const isStreaming = message.isLoading && !!textForMarkdown; // Condition for blinking cursor
                        contentToShow = (
                            <div ref={contentRef}>
                                <div
                                    className={`markdown-content break-words ${isStreaming ? 'is-streaming' : ''}`}
                                    dangerouslySetInnerHTML={{ __html: marked.parse(textForMarkdown || '') }}
                                />
                            </div>
                        );
                    }
                }
            }

            return (<div className={`flex items-start ${isUser ? 'justify-end group' : 'justify-start'} ${messageLineAnimationClasses} mb-1`}> <div className={`${bubbleBaseClasses} ${bubbleWidthClasses} ${bubbleRoleClasses}`} onClick={isUser ? () => onSelectUserMessage(message.id === selectedUserMessageId ? null : message.id) : undefined}> {contentToShow} {isUser && selectedUserMessageId === message.id && messageTextContent && (<button onClick={(e) => { e.stopPropagation(); handleCopyUserText(messageTextContent); }} className="absolute -bottom-3 -right-1 p-1.5 bg-gray-100 text-gray-600 border border-gray-300 rounded-full shadow-md hover:bg-gray-200 transition-all" aria-label="Copy user message"> {userCopied ? <CheckMarkIconSVG className="w-4 h-4" /> : <NewCopyIconSVG className="w-4 h-4 fill-current" />} </button>)} </div> </div>);
        };

        const ChatInterface = ({ messages, onSendMessage, isLoading, onStopGeneration, onRegenerateLastTextMessage, onNewChat, setChatError, currentChatId, onDeleteAiMessagePair, selectedUserMessageId, setSelectedUserMessageId, editingMessageId, editText, setEditText, onSaveEdit, onCancelEdit, onStartEdit, selectedModel, setSelectedModel, setToast }) => {
            const [inputText, setInputText] = useState(''); const [selectedFiles, setSelectedFiles] = useState([]);
            const [isModelSelectorOpen, setIsModelSelectorOpen] = useState(false);
            const modelSelectorRef = useRef(null);
            const fileInputRef = useRef(null); const messagesEndRef = useRef(null); const chatContainerRef = useRef(null); const contentEditableRef = useRef(null);
            const isAtBottomRef = useRef(true);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (modelSelectorRef.current && !modelSelectorRef.current.contains(event.target)) {
                        setIsModelSelectorOpen(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, []);

            useEffect(() => {
                const container = chatContainerRef.current;
                const handleScroll = () => {
                    if (container) {
                        const { scrollTop, scrollHeight, clientHeight } = container;
                        isAtBottomRef.current = scrollHeight - scrollTop - clientHeight < 20;
                    }
                };
                container?.addEventListener('scroll', handleScroll, { passive: true });
                return () => container?.removeEventListener('scroll', handleScroll);
            }, []);

            useEffect(() => {
                if (isAtBottomRef.current && messagesEndRef.current) {
                    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages]);

            useEffect(() => { if (contentEditableRef.current) { contentEditableRef.current.style.height = 'auto'; const maxHeight = parseInt(getComputedStyle(contentEditableRef.current).maxHeight, 10); let newHeight = contentEditableRef.current.scrollHeight; if (maxHeight && newHeight > maxHeight) { newHeight = maxHeight; } contentEditableRef.current.style.height = `${newHeight}px`; } }, [inputText, selectedFiles]);

            const resizeImage = (file, maxDimension = 1280, quality = 0.85) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let { width, height } = img;
                            if (width > height) {
                                if (width > maxDimension) {
                                    height *= maxDimension / width;
                                    width = maxDimension;
                                }
                            } else {
                                if (height > maxDimension) {
                                    width *= maxDimension / height;
                                    height = maxDimension;
                                }
                            }
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            const dataUrl = canvas.toDataURL(file.type === 'image/png' ? 'image/png' : 'image/jpeg', quality);
                            resolve(dataUrl.split(',')[1]);
                        };
                        img.onerror = reject;
                    };
                    reader.onerror = reject;
                });
            };

            const handleFileChange = (event) => { const files = Array.from(event.target.files); processAndSetFiles(files); if (fileInputRef.current) fileInputRef.current.value = ""; };
            const handlePaste = (event) => { const pastedText = event.clipboardData.getData('text/plain'); const pastedFiles = Array.from(event.clipboardData.files); if (pastedFiles.length > 0) { event.preventDefault(); processAndSetFiles(pastedFiles, true); } };

            const processAndSetFiles = (filesArray, isFromPaste = false) => {
                if (!filesArray.length) return false;
                let filesToProcess = []; let currentTotalSize = selectedFiles.reduce((acc, curr) => acc + (curr.file?.size || 0), 0);
                let didProcessAnyFile = false; let localErrorMessage = null;

                for (const file of filesArray) {
                    const isImage = file.type.startsWith('image/');
                    const isTxt = file.type === 'text/plain' || (file.name && file.name.toLowerCase().endsWith('.txt'));

                    if (!isImage && !isTxt) { if (isFromPaste) console.log(`Pasted unsupported file: ${file.name} (${file.type})`); else localErrorMessage = `File "${file.name}" (type: ${file.type}) is not supported. Only images and .txt files are allowed.`; continue; }
                    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) { localErrorMessage = `File "${file.name}" is larger than ${MAX_FILE_SIZE_MB}MB.`; continue; }
                    if (currentTotalSize + file.size > MAX_TOTAL_FILES_SIZE_MB * 1024 * 1024) { localErrorMessage = `Total file size cannot exceed ${MAX_TOTAL_FILES_SIZE_MB}MB.`; break; }
                    filesToProcess.push(file); currentTotalSize += file.size; didProcessAnyFile = true;
                }

                if (localErrorMessage) { setChatError(localErrorMessage); } else { setChatError(null); }

                if (filesToProcess.length > 0) {
                    const placeholderFiles = filesToProcess.map(file => ({ id: Date.now().toString(36) + Math.random().toString(36).substring(2) + file.name, name: file.name, type: file.type, isLoading: true, file: file, }));
                    setSelectedFiles(prev => [...prev, ...placeholderFiles]);
                    placeholderFiles.forEach(placeholder => {
                        const { id, file } = placeholder;
                        const processSingleFile = async () => {
                            try {
                                let apiData;
                                if (file.type.startsWith('image/')) {
                                    const base64Data = await resizeImage(file);
                                    apiData = { mimeType: file.type, data: base64Data };
                                } else {
                                    const textContent = await file.text(); apiData = { textContent: textContent };
                                }
                                setSelectedFiles(prev => prev.map(p => p.id === id ? { ...p, isLoading: false, apiData: apiData } : p));
                            } catch (error) {
                                console.error('Error processing file:', error); setChatError(`Error processing file "${file.name}".`); setSelectedFiles(prev => prev.filter(p => p.id !== id));
                            }
                        };
                        processSingleFile();
                    });
                    return didProcessAnyFile;
                }
                return false;
            };

            const removeSelectedFile = (fileId) => { setSelectedFiles(prev => prev.filter(f => f.id !== fileId)); };
            const handleInputFromTextarea = (e) => { setInputText(e.target.value); };

            const handleSubmit = (e) => {
                if (e) e.preventDefault();
                const currentText = contentEditableRef.current?.value.trim() || '';
                if (!currentText && selectedFiles.length === 0) return;
                setChatError(null);

                // Store message content before clearing
                const messageToSend = currentText;
                const filesToSend = [...selectedFiles];

                // Clear input immediately to prevent jerky movement
                if (contentEditableRef.current) contentEditableRef.current.value = '';
                setInputText('');
                setSelectedFiles([]);

                // Send message after clearing input
                onSendMessage(messageToSend, filesToSend);
            };

            const handleContentEditableKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { const isLikelyDesktop = window.innerWidth > 768; if (isLikelyDesktop) { e.preventDefault(); if (!isSendButtonActuallyDisabled) { handleSubmit(e); } } } };
            const isAiCurrentlyProcessing = messages.some(m => m.role === 'model' && m.isLoading);
            const currentInputTextFromEditable = contentEditableRef.current?.value?.trim() || '';
            const isSendButtonActuallyDisabled = (!isAiCurrentlyProcessing && (isLoading || (currentInputTextFromEditable === '' && selectedFiles.length === 0) || selectedFiles.some(f => f.isLoading)));
            const sendOrStopButtonBaseClasses = "w-8 h-8 flex items-center justify-center font-semibold rounded-full transition-all duration-150 ease-in-out transform active:animate-button-press focus:outline-none";
            let sendOrStopButtonDynamicClasses = isAiCurrentlyProcessing ? "bg-slate-500 hover:bg-slate-600 text-white" : (isSendButtonActuallyDisabled ? "bg-brand-send-active opacity-60 text-white cursor-not-allowed" : "bg-brand-send-active hover:bg-brand-send-hover text-white focus:ring-2 focus:ring-offset-1 focus:ring-brand-send-active/50");

            useEffect(() => {
                if (contentEditableRef.current) { contentEditableRef.current.value = ''; }
                setInputText('');
                setSelectedFiles([]);
            }, [currentChatId]);

            const activeMessages = messages.filter(m => (m.role !== 'system' || m.isError) && m.id !== 'loading_chat_indicator');

            return (<div className="w-full h-full flex flex-col bg-white md:rounded-xl shadow-chat-window overflow-hidden"> <header className="p-3 flex items-center justify-between flex-shrink-0 bg-white border-b-2 border-gray-200 shadow-header">
                <div className="flex items-center flex-grow">
                    <NewEmptyStateIconSVG className="w-6 h-6 mr-2 text-brand-send-active" />
                    <h1 className="text-xl font-sans font-semibold text-gray-800 text-left">AlphaGPT</h1>
                </div> <button onClick={() => { onNewChat(); setSelectedUserMessageId(null); }} className="p-1.5 text-text-secondary hover:text-brand-primary rounded-full hover:bg-interactive-hover/70 transition-colors focus:outline-none" aria-label="New Chat" disabled={isLoading || isAiCurrentlyProcessing} > <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6"> <path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zM12.75 9a.75.75 0 00-1.5 0v2.25H9a.75.75 0 000 1.5h2.25V15a.75.75 0 001.5 0v-2.25H15a.75.75 0 000-1.5h-2.25V9z" clipRule="evenodd" /> </svg> </button> </header> <div ref={chatContainerRef} className="flex-grow overflow-y-auto chat-messages-container relative bg-surface-chat-area"> <div className="w-full max-w-3xl mx-auto p-4 md:p-5 space-y-3 md:space-y-4">
                    {activeMessages.length === 0 && !isLoading ? (
                        <div className="absolute inset-0 flex flex-col items-center justify-center text-center pointer-events-none p-8 animate-fade-in-up opacity-0" style={{ animationDelay: '0.2s', animationFillMode: 'forwards' }}>
                            <NewEmptyStateIconSVG className="w-16 h-16 mb-5 text-brand-send-active" />
                            <p className="text-2xl lg:text-3xl font-sans font-medium text-gray-800 leading-tight">AlphaGPT Intelligence</p>
                        </div>
                    ) : null}
                    {messages.map((msg, idx) => {
                        const isThisMessageAiAndFinalized = msg.role === 'model' && !msg.isLoading && !msg.isError &&
                            ((typeof msg.finalAnswerText === 'string' && msg.finalAnswerText));

                        let isEffectivelyLastAiMessageForButtons = false;
                        if (isThisMessageAiAndFinalized) {
                            isEffectivelyLastAiMessageForButtons = true;
                            for (let k = idx + 1; k < messages.length; k++) {
                                const nextMsg = messages[k];
                                if (nextMsg.role === 'system' || (nextMsg.role === 'model' && nextMsg.isLoading)) continue;
                                if (nextMsg.role === 'user') {
                                    isEffectivelyLastAiMessageForButtons = false;
                                    break;
                                }
                                if (nextMsg.role === 'model' && !nextMsg.isLoading && !nextMsg.isError) {
                                    isEffectivelyLastAiMessageForButtons = false;
                                    break;
                                }
                            }
                        }

                        let canThisAiMessageBeRegenerated = false;
                        if (isEffectivelyLastAiMessageForButtons) {
                            let userPromptIndex = -1;
                            for (let i = idx - 1; i >= 0; i--) {
                                if (messages[i].role === 'user') {
                                    let interveningUserMessageBetweenThisAiAndItsUserPrompt = false;
                                    for (let j = i + 1; j < idx; j++) {
                                        if (messages[j].role === 'user') {
                                            interveningUserMessageBetweenThisAiAndItsUserPrompt = true; break;
                                        }
                                    }
                                    if (!interveningUserMessageBetweenThisAiAndItsUserPrompt) {
                                        userPromptIndex = i; break;
                                    }
                                }
                            }
                            canThisAiMessageBeRegenerated = userPromptIndex !== -1;
                        }

                        return (<React.Fragment key={msg.id}> {((msg.role === 'user' && ((msg.parts && msg.parts[0]?.text) || msg.text || msg.attachedFiles?.length > 0 || msg.uiOnlyAttachedFiles?.length > 0)) || (msg.role === 'model') || msg.role === 'system' || msg.isError) && (<div> <ChatMessageItem message={msg} selectedUserMessageId={selectedUserMessageId} onSelectUserMessage={setSelectedUserMessageId} editingMessageId={editingMessageId} editText={editText} setEditText={setEditText} onSaveEdit={onSaveEdit} onCancelEdit={onCancelEdit} /> </div>)}
                            {isEffectivelyLastAiMessageForButtons && msg.id !== editingMessageId && (
                                <div className={`flex items-center space-x-2 mt-1 ml-0 justify-start mb-2`}>
                                    {canThisAiMessageBeRegenerated && (<button onClick={() => { setChatError(null); onRegenerateLastTextMessage(msg.id); setSelectedUserMessageId(null); }} className="p-1.5 rounded-full text-text-subtle hover:text-brand-primary hover:bg-interactive-hover/70 transition-all duration-150 group focus:outline-none focus:ring-1 focus:ring-brand-primary/50" aria-label="Regenerate response" disabled={isLoading || isAiCurrentlyProcessing} > <NewRefreshIcon className="w-5 h-5 transition-transform duration-200" /> </button>)}
                                    <ChatMessageItemOptions message={msg} onDeleteAiMessagePair={onDeleteAiMessagePair} onStartEdit={onStartEdit} />
                                </div>
                            )}
                        </React.Fragment>)
                    })} <div ref={messagesEndRef} className="h-1" /> </div> </div>
                <form onSubmit={handleSubmit} className="bg-surface-chat-area flex-shrink-0">
                    <div className="p-2 md:p-3">
                        <div className="w-full max-w-3xl mx-auto">
                            {selectedFiles.some(f => f.type.startsWith('image/')) && (<div className="image-preview-container-input mb-2"> {selectedFiles.filter(f => f.type.startsWith('image/')).map(file => (<div key={file.id} className="relative w-14 h-14 rounded-md overflow-hidden shadow-sm group border border-gray-200"> {file.isLoading ? (<div className="w-full h-full flex items-center justify-center bg-gray-100"> <div className="w-4 h-4 border-2 border-gray-300 border-t-brand-primary rounded-full animate-spin"></div> </div>) : (<img src={`data:${file.apiData.mimeType};base64,${file.apiData.data}`} alt={file.name} className="w-full h-full object-cover" />)} <button type="button" onClick={() => removeSelectedFile(file.id)} className="absolute top-0.5 right-0.5 w-5 h-5 bg-black/50 hover:bg-black/70 text-white rounded-full flex items-center justify-center transition-opacity focus:outline-none opacity-100" aria-label="Remove image" > <NewCloseIconSVG className="w-3 h-3" /> </button> </div>))} </div>)}
                            {selectedFiles.some(f => !f.type.startsWith('image/')) && (<div className={`file-pill-container ${selectedFiles.some(f => f.type.startsWith('image/')) ? 'mt-1.5' : ''} mb-2`}> {selectedFiles.filter(f => !f.type.startsWith('image/')).map(file => (<div key={file.id} className="file-pill"> {file.isLoading ? <div className="w-3 h-3 border-2 border-gray-300 border-t-brand-primary rounded-full animate-spin mr-1.5"></div> : <FileTextIcon className="file-pill-icon" />} <span className="file-pill-name">{file.name}</span> <button type="button" onClick={() => removeSelectedFile(file.id)} className="file-pill-remove"> <i className="fas fa-times"></i> </button> </div>))} </div>)}

                            <div className="relative bg-white border border-gray-300 focus-within:border-[#666362] rounded-2xl">
                                <textarea
                                    id="chat-input"
                                    ref={contentEditableRef}
                                    value={inputText}
                                    onChange={(e) => setInputText(e.target.value)}
                                    onPaste={handlePaste}
                                    onKeyDown={handleContentEditableKeyDown}
                                    className="w-full bg-transparent text-gray-900 placeholder-gray-500 pl-3 pr-16 pt-3 pb-16 resize-none focus:outline-none"
                                    placeholder="Ask AlphaGPT"
                                    rows="1"
                                    disabled={isLoading || isAiCurrentlyProcessing}
                                    style={{ maxHeight: '150px', minHeight: '48px' }}
                                />

                                {/* Invisible barrier to prevent text from overlapping buttons */}
                                <div className="absolute bottom-0 left-0 right-0 h-14 bg-white pointer-events-none rounded-b-2xl"></div>

                                <button
                                    type={isAiCurrentlyProcessing ? "button" : "submit"}
                                    onClick={isAiCurrentlyProcessing ? onStopGeneration : undefined}
                                    disabled={isSendButtonActuallyDisabled}
                                    className={`absolute right-4 top-1/2 -translate-y-1/2 -mt-4 w-9 h-9 rounded-full flex items-center justify-center ${sendOrStopButtonDynamicClasses}`}
                                    aria-label={isAiCurrentlyProcessing ? "Stop generation" : "Send message"}
                                >
                                    {isAiCurrentlyProcessing ? (<i className="fas fa-stop text-sm"></i>) : (<i className="fas fa-arrow-up w-5 h-5"></i>)}
                                </button>

                                {/* Plus button positioned at bottom left corner */}
                                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" multiple accept="image/*,.txt,text/plain" disabled={isLoading || isAiCurrentlyProcessing} />
                                <button
                                    type="button"
                                    onClick={() => fileInputRef.current?.click()}
                                    className="absolute left-3 bottom-1 w-8 h-8 flex items-center justify-center text-gray-500 hover:text-gray-700 rounded-full bg-white hover:bg-gray-200/70 border border-gray-300 transition-colors duration-150 disabled:opacity-50 flex-shrink-0 focus:outline-none"
                                    aria-label="Attach file"
                                    disabled={isLoading || isAiCurrentlyProcessing}
                                >
                                    <PlusIcon />
                                </button>

                                {/* Model selector positioned separately */}
                                <div className="absolute left-14 bottom-1">
                                    <div ref={modelSelectorRef} className="relative">
                                        <button type="button" onClick={() => setIsModelSelectorOpen(prev => !prev)} disabled={isLoading || isAiCurrentlyProcessing} className="flex items-center space-x-1.5 h-6 px-2 text-xs font-medium text-gray-400 bg-white border border-gray-300 rounded-md disabled:opacity-50 focus:outline-none hover:text-gray-700 hover:bg-gray-200/70 transition-colors duration-150">
                                            <span className={selectedModel ? 'text-black font-medium' : 'text-gray-400'}>{CONFIG.models.list.find(m => m.id === selectedModel)?.uiName || 'Model'}</span>
                                            <i className="fas fa-chevron-down fa-2xs text-gray-500"></i>
                                        </button>
                                        {isModelSelectorOpen && (
                                            <div className="absolute bottom-full left-0 mb-2 w-36 bg-white border border-gray-300 rounded-md shadow-xl z-20 p-1 animate-scale-in-subtle origin-bottom-left">
                                                {CONFIG.models.list.map(model => (
                                                    <button key={model.id} onClick={() => { setSelectedModel(model.id); setIsModelSelectorOpen(false); }} className={`w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center space-x-2 transition-colors ${selectedModel === model.id ? 'font-semibold text-black bg-gray-100' : 'text-black hover:bg-gray-100'}`}>
                                                        <span>{model.uiName}</span>
                                                    </button>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            );
        };

        const Toast = ({ message, type = 'info', onDismiss }) => {
            const baseClasses = "flex items-center p-3 space-x-2.5 rounded-lg shadow-lg max-w-[90vw] sm:max-w-sm";
            const typeClasses = {
                info: 'text-gray-600 bg-white border border-gray-200',
                error: 'text-red-700 bg-red-100 border border-red-200',
                success: 'text-green-700 bg-green-100 border border-green-200',
            };
            const iconClasses = {
                info: 'fa-info-circle text-blue-500',
                error: 'fa-exclamation-triangle text-red-500',
                success: 'fa-check-circle text-green-500',
            };

            return (
                <div className={`${baseClasses} ${typeClasses[type]} animate-fade-in-up`} role="alert">
                    <i className={`fas ${iconClasses[type]} flex-shrink-0 w-5 h-5`}></i>
                    <span className="text-xs font-medium">{message}</span>
                    <button onClick={onDismiss} className="p-1.5 -m-1.5 ml-auto text-gray-400 hover:text-gray-900 rounded-lg hover:bg-gray-100/50 focus:outline-none focus:ring-2 focus:ring-gray-300 flex-shrink-0">
                        <NewCloseIconSVG className="w-3.5 h-3.5" />
                    </button>
                </div>
            );
        };

        const App = () => {
            const [currentUser, setCurrentUser] = useState({ uid: 'guest_user', email: 'Guest User' }); const [authLoading, setAuthLoading] = useState(false); const [chatMessages, setChatMessages] = useState([]); const [isChatLoading, setIsChatLoading] = useState(false); const [chatError, setChatError] = useState(null); const [currentChatId, setCurrentChatId] = useState('session_chat_init');
            const [selectedUserMessageId, setSelectedUserMessageId] = useState(null);
            const [editingMessageId, setEditingMessageId] = useState(null);
            const [editText, setEditText] = useState('');
            const [selectedModel, setSelectedModel] = useState(CONFIG.models.default);
            const [toast, setToast] = useState(null);
            const isStoppingGenerationRef = useRef(false); const streamTextBuffer = useRef("");

            useEffect(() => {
                document.documentElement.style.setProperty('--shimmer-duration', `${CONFIG.settings.shimmerSpeedSeconds}s`);
            }, []);

            useEffect(() => {
                if (toast) {
                    const timer = setTimeout(() => setToast(null), 4000);
                    return () => clearTimeout(timer);
                }
            }, [toast]);

            useEffect(() => { if (chatError) { const errorId = Date.now() + '_sys_validation_err'; const newErrorMsg = { id: errorId, role: 'system', text: chatError, isError: true, timestamp: new Date().getTime() }; setChatMessages(prev => { const lastMessage = prev[prev.length - 1]; if (lastMessage && lastMessage.id.includes('_sys_validation_err') && lastMessage.text === chatError) return prev; return [...prev, newErrorMsg]; }); } }, [chatError]);
            const handleNewChat = useCallback(() => { const newSessionId = 'session_chat_' + Date.now().toString(36) + Math.random().toString(36).substring(2); setCurrentChatId(newSessionId); setChatMessages([]); setChatError(null); return newSessionId; }, []);

            const getA4fHistory = (currentMessagesFromState, provider = 'gemini') => {
                const openAiMessages = currentMessagesFromState
                    .filter(msg => !(
                        msg.role === 'system' ||
                        (msg.role === 'model' && msg.isLoading && !(typeof msg.finalAnswerText === 'string' && msg.finalAnswerText)) ||
                        msg.isError || msg.showSourcesOnly
                    ))
                    .map(msg => {
                        const role = msg.role === 'model' ? 'assistant' : msg.role;
                        let content;

                        if (role === 'user') {
                            let textParts = (msg.parts || []).filter(p => p.text).map(p => p.text).join(' ').trim();
                            if (!textParts && msg.text) {
                                textParts = msg.text.trim();
                            }

                            const filesToConsider = msg.uiOnlyAttachedFiles || msg.attachedFiles || [];

                            const textFilesContent = filesToConsider
                                .filter(file => (file.name?.toLowerCase().endsWith('.txt') || file.type === 'text/plain') && file.apiData?.textContent)
                                .map(file => `\n[Content of attached file: ${file.name}]\n${file.apiData.textContent}\n[End of file: ${file.name}]\n`)
                                .join('');

                            const fullText = (textParts + textFilesContent).trim();

                            const imageFiles = filesToConsider
                                .filter(file => file.type.startsWith('image/') && file.apiData?.mimeType && file.apiData?.data);

                            if (imageFiles.length > 0) {
                                if (provider === 'pollinations') {
                                    // OpenAI format for Pollinations
                                    const contentArray = [];
                                    if (fullText) {
                                        contentArray.push({ type: 'text', text: fullText });
                                    }
                                    imageFiles.forEach(file => {
                                        contentArray.push({
                                            type: 'image_url',
                                            image_url: {
                                                url: `data:${file.apiData.mimeType};base64,${file.apiData.data}`
                                            }
                                        });
                                    });
                                    content = contentArray;
                                } else {
                                    // Gemini format
                                    const images = imageFiles.map(file => ({
                                        inline_data: {
                                            mime_type: file.apiData.mimeType,
                                            data: file.apiData.data
                                        }
                                    }));
                                    content = [{ text: fullText }, ...images];
                                }
                            } else {
                                content = fullText;
                            }
                        } else { // assistant
                            content = msg.finalAnswerText || msg.text || (msg.parts?.[0]?.text || "");
                        }

                        if (!content || (Array.isArray(content) && content.length === 0) || (typeof content === 'string' && !content.trim())) {
                            return null;
                        }

                        return { role, content };
                    })
                    .filter(Boolean);

                const firstUserIndex = openAiMessages.findIndex(m => m.role === 'user');
                if (firstUserIndex > 0) {
                    return openAiMessages.slice(firstUserIndex);
                }
                if (openAiMessages.length === 1 && openAiMessages[0].role === 'assistant') {
                    return [];
                }
                return openAiMessages;
            };

            const handleStopGeneration = useCallback(() => {
                isStoppingGenerationRef.current = true;
            }, []);

            const addMessageToLocalChat = async (role, text, filesForDisplay, aiSpecificData = {}) => { const messageId = Date.now().toString(36) + Math.random().toString(36).substring(2); const messagePartsForDisplay = []; if (text) messagePartsForDisplay.push({ text: text }); const attachedFilesForLocalState = filesForDisplay.map(f => ({ id: f.id, name: f.name, type: f.type, apiData: f.apiData, isLoading: f.isLoading })); const messageData = { id: messageId, role: role, parts: messagePartsForDisplay.length > 0 ? messagePartsForDisplay : [{ text: "" }], text: text || "", timestamp: new Date().getTime(), ...(role === 'user' && attachedFilesForLocalState.length > 0 && { uiOnlyAttachedFiles: attachedFilesForLocalState }), ...(role === 'model' && aiSpecificData.modelUsed && { modelUsed: aiSpecificData.modelUsed }), ...(aiSpecificData.searchUsed && { searchUsed: true }) }; setChatMessages(prev => [...prev, messageData]); return messageId; };

            const performSerperSearch = async (query) => {
                try {
                    const response = await fetch("https://google.serper.dev/search", {
                        method: "POST",
                        headers: {
                            'X-API-KEY': CONFIG.api.serper.apiKey,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            q: query,
                            num: 10
                        }),
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `Serper API failed with status ${response.status}`);
                    }
                    const data = await response.json();
                    if (!data.organic || data.organic.length === 0) {
                        return { toolContent: "No results found.", sources: [] };
                    }
                    const sources = data.organic.map(item => ({
                        link: item.link,
                        title: item.title,
                        snippet: item.snippet,
                        favicon: item.favicon
                    }));
                    const toolContent = JSON.stringify(sources.map(s => ({ title: s.title, link: s.link, snippet: s.snippet })));
                    return { toolContent, sources };
                } catch (error) {
                    console.error("Serper Search Error:", error);
                    return { toolContent: `Search failed with error: ${error.message}`, sources: [] };
                }
            };

            const callPollinationsAPI = async (messages, modelToUse) => {
                try {
                    // Convert messages to OpenAI format for Pollinations API
                    const openAIMessages = messages.map(msg => {
                        if (msg.role === 'system') {
                            return { role: 'system', content: msg.content };
                        } else if (msg.role === 'model' || msg.role === 'assistant') {
                            return { role: 'assistant', content: msg.content };
                        } else {
                            // Handle user messages with potential images (OpenAI format)
                            if (Array.isArray(msg.content)) {
                                // Convert from Gemini format to OpenAI format
                                const content = msg.content.map(part => {
                                    if (part.text) {
                                        return { type: 'text', text: part.text };
                                    } else if (part.inline_data) {
                                        // Convert Gemini inline_data to OpenAI image_url format
                                        return {
                                            type: 'image_url',
                                            image_url: {
                                                url: `data:${part.inline_data.mime_type};base64,${part.inline_data.data}`
                                            }
                                        };
                                    }
                                    return part;
                                });
                                return { role: 'user', content: content };
                            } else {
                                return { role: 'user', content: msg.content };
                            }
                        }
                    });

                    const response = await fetch(CONFIG.api.pollinations.baseUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: modelToUse,
                            messages: openAIMessages,
                            temperature: CONFIG.settings.temperature,
                            max_tokens: 8192,
                            token: CONFIG.api.pollinations.apiKey,
                            stream: false
                        })
                    });

                    if (!response.ok) {
                        const errorBody = await response.json().catch(() => ({}));
                        throw new Error(`Pollinations API failed with status ${response.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
                    }

                    const data = await response.json();
                    return data.choices?.[0]?.message?.content || "Sorry, I couldn't generate a response.";
                } catch (error) {
                    console.error("Pollinations API Error:", error);
                    throw error;
                }
            };

            const simulateTypingEffect = async (targetAiMessageUiId, fullText) => {
                streamTextBuffer.current = "";
                for (const char of fullText) {
                    if (isStoppingGenerationRef.current) break;
                    streamTextBuffer.current += char;
                    setChatMessages(prev => prev.map(msg =>
                        msg.id === targetAiMessageUiId
                            ? { ...msg, isLoading: true, loadingText: '', finalAnswerText: streamTextBuffer.current, text: streamTextBuffer.current, parts: [{ text: streamTextBuffer.current }] }
                            : msg
                    ));
                    await new Promise(resolve => setTimeout(resolve, CONFIG.settings.streamingSpeedMs));
                }
            };

            const _streamAiResponse = async (targetAiMessageUiId, historyForA4f, modelToUse) => {
                isStoppingGenerationRef.current = false;
                setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, loadingText: "Thinking..." } : m));

                const initialHistory = [{ role: 'system', content: getSystemInstruction() }, ...historyForA4f];

                // Determine which provider to use based on the model
                const modelConfig = CONFIG.models.list.find(m => m.id === modelToUse);
                const provider = modelConfig?.provider || 'gemini';

                try {
                    let initialContent = "";

                    if (provider === 'gemini') {
                        // Gemini API call
                        const geminiContents = initialHistory.map(msg => {
                            const role = msg.role === 'assistant' ? 'model' : 'user';

                            // Handle complex content (text + images)
                            if (Array.isArray(msg.content)) {
                                const parts = msg.content.map(part => {
                                    if (part.text) {
                                        return { text: part.text };
                                    } else if (part.inline_data) {
                                        return { inline_data: part.inline_data };
                                    }
                                    return part;
                                });
                                return { role, parts };
                            } else {
                                // Handle simple text content
                                return { role, parts: [{ text: msg.content }] };
                            }
                        });

                        const initialResponse = await fetch(`${CONFIG.api.gemini.baseUrl}/${modelToUse}:generateContent?key=${CONFIG.api.gemini.apiKey}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: geminiContents,
                                generationConfig: {
                                    temperature: CONFIG.settings.temperature,
                                    maxOutputTokens: 8192
                                }
                            }),
                        });

                        if (!initialResponse.ok) {
                            const errorBody = await initialResponse.json().catch(() => ({}));
                            throw new Error(`Request failed with status ${initialResponse.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
                        }

                        const initialData = await initialResponse.json();
                        initialContent = initialData.candidates?.[0]?.content?.parts?.[0]?.text || "";
                    } else if (provider === 'pollinations') {
                        // Pollinations API call
                        initialContent = await callPollinationsAPI(initialHistory, modelToUse);
                    }

                    let finalAnswerText = "";
                    const searchMatch = initialContent.match(/\[SEARCH: "([^"]+)"\]/);

                    if (searchMatch && searchMatch[1]) {
                        const searchQuery = searchMatch[1];
                        setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, searchQuery: searchQuery, loadingText: null } : m));

                        const { toolContent, sources } = await performSerperSearch(searchQuery);

                        // Show sources briefly before generating response
                        setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, sources: sources, showSourcesOnly: true, searchQuery: null } : m));

                        // Brief delay to show sources to user
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        if (isStoppingGenerationRef.current) throw new Error("Generation stopped");

                        // Continue with response generation while keeping sources visible and show analyzing indicator
                        setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isLoading: true, sources: sources, showSourcesOnly: false, searchQuery: null, isAnalyzing: true } : m));

                        // Create enhanced history with search results for single API call
                        const enhancedHistory = [
                            ...initialHistory,
                            { role: 'user', content: `${initialHistory[initialHistory.length - 1].content}\n\nSearch Results for "${searchQuery}":\n${toolContent}\n\nPlease use this information to answer my question in Roman Urdu. Don't mention the search process.` }
                        ];

                        // Single API call with search results
                        if (provider === 'gemini') {
                            const geminiContents = enhancedHistory.map(msg => {
                                const role = msg.role === 'assistant' ? 'model' : 'user';

                                // Handle complex content (text + images)
                                if (Array.isArray(msg.content)) {
                                    const parts = msg.content.map(part => {
                                        if (part.text) {
                                            return { text: part.text };
                                        } else if (part.inline_data) {
                                            return { inline_data: part.inline_data };
                                        }
                                        return part;
                                    });
                                    return { role, parts };
                                } else {
                                    // Handle simple text content
                                    return { role, parts: [{ text: msg.content }] };
                                }
                            });

                            const response = await fetch(`${CONFIG.api.gemini.baseUrl}/${modelToUse}:generateContent?key=${CONFIG.api.gemini.apiKey}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    contents: geminiContents,
                                    generationConfig: {
                                        temperature: CONFIG.settings.temperature,
                                        maxOutputTokens: 8192
                                    }
                                }),
                            });

                            if (!response.ok) throw new Error("Search response request failed");
                            const data = await response.json();
                            finalAnswerText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't process the search results.";
                        } else if (provider === 'pollinations') {
                            finalAnswerText = await callPollinationsAPI(enhancedHistory, modelToUse);
                        }

                    } else {
                        finalAnswerText = initialContent;
                    }

                    // Clear indicators and start typing effect
                    setChatMessages(prev => prev.map(m => m.id === targetAiMessageUiId ? { ...m, isAnalyzing: false, showSourcesOnly: false, searchQuery: null } : m));
                    await simulateTypingEffect(targetAiMessageUiId, finalAnswerText);

                } catch (err) {
                    if (err.message !== "Generation stopped") {
                        console.error("AI stream error:", err);
                        let errorTextForUser = `A network error occurred. Please check your connection and try again. (${err.message})`;
                        setToast({ text: errorTextForUser, type: 'error' });
                        setChatMessages(prev => prev.map(msg => msg.id === targetAiMessageUiId ? { ...msg, isLoading: false, isError: true, finalAnswerText: errorTextForUser, text: errorTextForUser, parts: [{ text: errorTextForUser }], sources: null, showSourcesOnly: false } : msg));
                    }
                } finally {
                    if (isStoppingGenerationRef.current) {
                        streamTextBuffer.current += "\n\n*Generation stopped by user.*";
                    }
                    setChatMessages(prev => prev.map(msg => msg.id === targetAiMessageUiId ? { ...msg, isLoading: false, isAnalyzing: false, finalAnswerText: streamTextBuffer.current.trim(), text: streamTextBuffer.current.trim(), parts: [{ text: streamTextBuffer.current.trim() }], showSourcesOnly: false } : msg));
                    isStoppingGenerationRef.current = false;
                }
            };

            const handleSendChatMessage = useCallback(async (messageText, filesToSendFromInput) => {
                if (!messageText.trim() && filesToSendFromInput.length === 0) return;
                if (filesToSendFromInput.some(f => f.isLoading)) { setChatError("Please wait for all files to finish loading."); return; }
                setChatError(null);
                setIsChatLoading(true);

                const tempUserMessage = {
                    id: 'temp_user_' + Date.now(),
                    role: 'user',
                    text: messageText,
                    parts: messageText ? [{ text: messageText }] : [],
                    timestamp: new Date().getTime(),
                    uiOnlyAttachedFiles: filesToSendFromInput,
                };
                // Determine provider for history formatting
                const modelConfig = CONFIG.models.list.find(m => m.id === selectedModel);
                const provider = modelConfig?.provider || 'gemini';
                const historyForA4f = getA4fHistory([...chatMessages, tempUserMessage], provider);

                await addMessageToLocalChat('user', messageText, filesToSendFromInput);

                const aiPlaceholderUiId = Date.now().toString() + '_model_resp_temp_ui';

                const preliminaryAiPlaceholder = {
                    id: aiPlaceholderUiId, role: 'model', text: '', parts: [{ text: '' }], finalAnswerText: "",
                    timestamp: new Date().getTime(), isLoading: true, isError: false, sources: null, showSourcesOnly: false,
                    modelUsed: selectedModel, searchUsed: true, searchQuery: null, isAnalyzing: false,
                };
                setChatMessages(prev => [...prev.filter(m => m.id !== 'loading_chat_indicator'), preliminaryAiPlaceholder]);

                await _streamAiResponse(aiPlaceholderUiId, historyForA4f, selectedModel);
                setIsChatLoading(false);
            }, [chatMessages, currentChatId, selectedModel]);

            const handleRegenerateLastTextMessage = useCallback(async (aiMessageIdToRegenerate) => {
                setChatError(null);
                setIsChatLoading(true);

                const messagesSnapshot = [...chatMessages];
                let userPromptIndex = -1;
                const aiMessageIndex = messagesSnapshot.findIndex(m => m.id === aiMessageIdToRegenerate);

                if (aiMessageIndex === -1) { setToast({ text: "Cannot regenerate: Original AI message not found.", type: 'error' }); setIsChatLoading(false); return; }
                const modelUsedForOriginal = messagesSnapshot[aiMessageIndex].modelUsed || selectedModel;

                for (let i = aiMessageIndex - 1; i >= 0; i--) {
                    if (messagesSnapshot[i].role === 'user') {
                        userPromptIndex = i;
                        break;
                    }
                }

                if (userPromptIndex === -1) { setToast({ text: "Cannot regenerate: Original user prompt not found.", type: 'error' }); setIsChatLoading(false); return; }

                // Determine provider for history formatting
                const modelConfig = CONFIG.models.list.find(m => m.id === modelUsedForOriginal);
                const provider = modelConfig?.provider || 'gemini';
                const historyForApi = getA4fHistory(messagesSnapshot.slice(0, userPromptIndex + 1), provider);

                const newAiMessageId = Date.now().toString() + '_model_regen_ui';

                setChatMessages(prev => prev.map(msg =>
                    msg.id === aiMessageIdToRegenerate
                        ? {
                            id: newAiMessageId,
                            role: 'model', text: '', parts: [{ text: '' }], finalAnswerText: "",
                            timestamp: new Date().getTime(), isLoading: true,
                            isError: false, sources: null, modelUsed: modelUsedForOriginal, searchUsed: true,
                            showSourcesOnly: false, searchQuery: null, isAnalyzing: false,
                        }
                        : msg
                ));

                await _streamAiResponse(newAiMessageId, historyForApi, modelUsedForOriginal);
                setIsChatLoading(false);
            }, [chatMessages, currentChatId, selectedModel]);

            const handleDeleteAiMessagePair = async (aiMessageId) => { const currentMessages = [...chatMessages]; const aiMessageIndex = currentMessages.findIndex(msg => msg.id === aiMessageId); if (aiMessageIndex === -1) { setToast({ text: "Could not find the AI message to delete.", type: 'error' }); return; } let idsToDelete = [aiMessageId]; if (aiMessageIndex > 0) { let precedingUserMessage = null; for (let i = aiMessageIndex - 1; i >= 0; i--) { if (currentMessages[i].role === 'model') { break; } if (currentMessages[i].role === 'user') { let interveningUserMessage = false; for (let k = i + 1; k < aiMessageIndex; k++) { if (currentMessages[k].role === 'user') { interveningUserMessage = true; break; } } if (!interveningUserMessage) { precedingUserMessage = currentMessages[i]; } break; } } if (precedingUserMessage) { idsToDelete.push(precedingUserMessage.id); } } setChatMessages(prev => prev.filter(msg => !idsToDelete.includes(msg.id))); };
            const handleStartEdit = (id, currentText) => { setEditingMessageId(id); setEditText(currentText || ''); };
            const handleCancelEdit = () => { setEditingMessageId(null); setEditText(''); };
            const handleSaveEdit = (id) => { setChatMessages(prev => prev.map(msg => msg.id === id ? { ...msg, finalAnswerText: editText, text: editText, parts: [{ text: editText }] } : msg)); handleCancelEdit(); };

            if (authLoading) { return (<div className="h-full flex items-center justify-center bg-surface-main"> <div className="w-10 h-10 border-4 border-brand-primary border-t-transparent rounded-full animate-spin-continuous"></div> </div>); }
            return (
                <div className="h-full text-text-primary flex font-sans bg-surface-main relative">
                    {toast && (
                        <div className="absolute top-5 left-1/2 -translate-x-1/2 z-50">
                            <Toast message={toast.text} type={toast.type} onDismiss={() => setToast(null)} />
                        </div>
                    )}
                    <div className="flex-grow h-full flex flex-col min-w-0">
                        <ChatInterface
                            messages={chatMessages}
                            onSendMessage={handleSendChatMessage}
                            isLoading={isChatLoading}
                            onStopGeneration={handleStopGeneration}
                            onRegenerateLastTextMessage={handleRegenerateLastTextMessage}
                            onNewChat={handleNewChat}
                            setChatError={setChatError}
                            currentChatId={currentChatId}
                            onDeleteAiMessagePair={handleDeleteAiMessagePair}
                            selectedUserMessageId={selectedUserMessageId}
                            setSelectedUserMessageId={setSelectedUserMessageId}
                            editingMessageId={editingMessageId}
                            editText={editText}
                            setEditText={setEditText}
                            onSaveEdit={handleSaveEdit}
                            onCancelEdit={handleCancelEdit}
                            onStartEdit={handleStartEdit}
                            selectedModel={selectedModel}
                            setSelectedModel={setSelectedModel}
                            setToast={setToast}
                        />
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
</body>

</html>
